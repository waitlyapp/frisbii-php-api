<?php
/**
 * SubscriptionCancelPreview
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  Frisbii
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * API
 *
 * REST API to manage Frisbii resources
 *
 * The version of the OpenAPI document: 1
 * Contact: support@frisbii.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.6.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Frisbii\Model;

use \ArrayAccess;
use \Frisbii\ObjectSerializer;

/**
 * SubscriptionCancelPreview Class Doc Comment
 *
 * @category Class
 * @package  Frisbii
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class SubscriptionCancelPreview implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'SubscriptionCancelPreview';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'handle' => 'string',
        'customer' => 'string',
        'plan' => 'string',
        'state' => 'string',
        'test' => 'bool',
        'quantity' => 'int',
        'timezone' => 'string',
        'created' => '\DateTime',
        'renewing' => 'bool',
        'currency' => 'string',
        'planVersion' => 'int',
        'startDate' => '\DateTime',
        'isCancelled' => 'bool',
        'inTrial' => 'bool',
        'hasStarted' => 'bool',
        'renewalCount' => 'int',
        'paymentMethodAdded' => 'bool',
        'failedInvoices' => 'int',
        'failedAmount' => 'int',
        'cancelledInvoices' => 'int',
        'cancelledAmount' => 'int',
        'pendingInvoices' => 'int',
        'pendingAmount' => 'int',
        'dunningInvoices' => 'int',
        'dunningAmount' => 'int',
        'settledInvoices' => 'int',
        'settledAmount' => 'int',
        'refundedAmount' => 'int',
        'pendingAdditionalCosts' => 'int',
        'pendingAdditionalCostAmount' => 'int',
        'transferredAdditionalCosts' => 'int',
        'transferredAdditionalCostAmount' => 'int',
        'pendingCredits' => 'int',
        'pendingCreditAmount' => 'int',
        'transferredCredits' => 'int',
        'transferredCreditAmount' => 'int',
        'hostedPageLinks' => '\Frisbii\Model\SubscriptionLinks',
        'amount' => 'int',
        'expires' => '\DateTime',
        'reactivated' => '\DateTime',
        'activated' => '\DateTime',
        'coupons' => 'string[]',
        'amountInclVat' => 'bool',
        'endDate' => '\DateTime',
        'graceDuration' => 'int',
        'currentPeriodStart' => '\DateTime',
        'nextPeriodStart' => '\DateTime',
        'firstPeriodStart' => '\DateTime',
        'lastPeriodStart' => '\DateTime',
        'trialStart' => '\DateTime',
        'trialEnd' => '\DateTime',
        'cancelledDate' => '\DateTime',
        'expiredDate' => '\DateTime',
        'expireReason' => 'string',
        'onHoldDate' => '\DateTime',
        'onHoldReason' => 'string',
        'scheduledPlanChange' => 'string',
        'reminderEmailSent' => '\DateTime',
        'subscriptionDiscounts' => 'string[]',
        'pendingChange' => '\Frisbii\Model\SubscriptionChange',
        'subscriptionChanges' => '\Frisbii\Model\SubscriptionChange[]',
        'subscriptionAddOns' => 'string[]',
        'activePaymentMethods' => 'string[]',
        'meteredBillingProducts' => 'string[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'handle' => null,
        'customer' => null,
        'plan' => null,
        'state' => null,
        'test' => null,
        'quantity' => 'int32',
        'timezone' => null,
        'created' => 'date-time',
        'renewing' => null,
        'currency' => null,
        'planVersion' => 'int32',
        'startDate' => 'date-time',
        'isCancelled' => null,
        'inTrial' => null,
        'hasStarted' => null,
        'renewalCount' => 'int32',
        'paymentMethodAdded' => null,
        'failedInvoices' => 'int32',
        'failedAmount' => 'int64',
        'cancelledInvoices' => 'int32',
        'cancelledAmount' => 'int64',
        'pendingInvoices' => 'int32',
        'pendingAmount' => 'int64',
        'dunningInvoices' => 'int32',
        'dunningAmount' => 'int64',
        'settledInvoices' => 'int32',
        'settledAmount' => 'int64',
        'refundedAmount' => 'int64',
        'pendingAdditionalCosts' => 'int32',
        'pendingAdditionalCostAmount' => 'int64',
        'transferredAdditionalCosts' => 'int32',
        'transferredAdditionalCostAmount' => 'int64',
        'pendingCredits' => 'int32',
        'pendingCreditAmount' => 'int64',
        'transferredCredits' => 'int32',
        'transferredCreditAmount' => 'int64',
        'hostedPageLinks' => null,
        'amount' => 'int32',
        'expires' => 'date-time',
        'reactivated' => 'date-time',
        'activated' => 'date-time',
        'coupons' => null,
        'amountInclVat' => null,
        'endDate' => 'date-time',
        'graceDuration' => 'int64',
        'currentPeriodStart' => 'date-time',
        'nextPeriodStart' => 'date-time',
        'firstPeriodStart' => 'date-time',
        'lastPeriodStart' => 'date-time',
        'trialStart' => 'date-time',
        'trialEnd' => 'date-time',
        'cancelledDate' => 'date-time',
        'expiredDate' => 'date-time',
        'expireReason' => null,
        'onHoldDate' => 'date-time',
        'onHoldReason' => null,
        'scheduledPlanChange' => null,
        'reminderEmailSent' => 'date-time',
        'subscriptionDiscounts' => null,
        'pendingChange' => null,
        'subscriptionChanges' => null,
        'subscriptionAddOns' => null,
        'activePaymentMethods' => null,
        'meteredBillingProducts' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'handle' => false,
        'customer' => false,
        'plan' => false,
        'state' => false,
        'test' => false,
        'quantity' => false,
        'timezone' => false,
        'created' => false,
        'renewing' => false,
        'currency' => false,
        'planVersion' => false,
        'startDate' => false,
        'isCancelled' => false,
        'inTrial' => false,
        'hasStarted' => false,
        'renewalCount' => false,
        'paymentMethodAdded' => false,
        'failedInvoices' => false,
        'failedAmount' => false,
        'cancelledInvoices' => false,
        'cancelledAmount' => false,
        'pendingInvoices' => false,
        'pendingAmount' => false,
        'dunningInvoices' => false,
        'dunningAmount' => false,
        'settledInvoices' => false,
        'settledAmount' => false,
        'refundedAmount' => false,
        'pendingAdditionalCosts' => false,
        'pendingAdditionalCostAmount' => false,
        'transferredAdditionalCosts' => false,
        'transferredAdditionalCostAmount' => false,
        'pendingCredits' => false,
        'pendingCreditAmount' => false,
        'transferredCredits' => false,
        'transferredCreditAmount' => false,
        'hostedPageLinks' => false,
        'amount' => false,
        'expires' => false,
        'reactivated' => false,
        'activated' => false,
        'coupons' => false,
        'amountInclVat' => false,
        'endDate' => false,
        'graceDuration' => false,
        'currentPeriodStart' => false,
        'nextPeriodStart' => false,
        'firstPeriodStart' => false,
        'lastPeriodStart' => false,
        'trialStart' => false,
        'trialEnd' => false,
        'cancelledDate' => false,
        'expiredDate' => false,
        'expireReason' => false,
        'onHoldDate' => false,
        'onHoldReason' => false,
        'scheduledPlanChange' => false,
        'reminderEmailSent' => false,
        'subscriptionDiscounts' => false,
        'pendingChange' => false,
        'subscriptionChanges' => false,
        'subscriptionAddOns' => false,
        'activePaymentMethods' => false,
        'meteredBillingProducts' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'handle' => 'handle',
        'customer' => 'customer',
        'plan' => 'plan',
        'state' => 'state',
        'test' => 'test',
        'quantity' => 'quantity',
        'timezone' => 'timezone',
        'created' => 'created',
        'renewing' => 'renewing',
        'currency' => 'currency',
        'planVersion' => 'plan_version',
        'startDate' => 'start_date',
        'isCancelled' => 'is_cancelled',
        'inTrial' => 'in_trial',
        'hasStarted' => 'has_started',
        'renewalCount' => 'renewal_count',
        'paymentMethodAdded' => 'payment_method_added',
        'failedInvoices' => 'failed_invoices',
        'failedAmount' => 'failed_amount',
        'cancelledInvoices' => 'cancelled_invoices',
        'cancelledAmount' => 'cancelled_amount',
        'pendingInvoices' => 'pending_invoices',
        'pendingAmount' => 'pending_amount',
        'dunningInvoices' => 'dunning_invoices',
        'dunningAmount' => 'dunning_amount',
        'settledInvoices' => 'settled_invoices',
        'settledAmount' => 'settled_amount',
        'refundedAmount' => 'refunded_amount',
        'pendingAdditionalCosts' => 'pending_additional_costs',
        'pendingAdditionalCostAmount' => 'pending_additional_cost_amount',
        'transferredAdditionalCosts' => 'transferred_additional_costs',
        'transferredAdditionalCostAmount' => 'transferred_additional_cost_amount',
        'pendingCredits' => 'pending_credits',
        'pendingCreditAmount' => 'pending_credit_amount',
        'transferredCredits' => 'transferred_credits',
        'transferredCreditAmount' => 'transferred_credit_amount',
        'hostedPageLinks' => 'hosted_page_links',
        'amount' => 'amount',
        'expires' => 'expires',
        'reactivated' => 'reactivated',
        'activated' => 'activated',
        'coupons' => 'coupons',
        'amountInclVat' => 'amount_incl_vat',
        'endDate' => 'end_date',
        'graceDuration' => 'grace_duration',
        'currentPeriodStart' => 'current_period_start',
        'nextPeriodStart' => 'next_period_start',
        'firstPeriodStart' => 'first_period_start',
        'lastPeriodStart' => 'last_period_start',
        'trialStart' => 'trial_start',
        'trialEnd' => 'trial_end',
        'cancelledDate' => 'cancelled_date',
        'expiredDate' => 'expired_date',
        'expireReason' => 'expire_reason',
        'onHoldDate' => 'on_hold_date',
        'onHoldReason' => 'on_hold_reason',
        'scheduledPlanChange' => 'scheduled_plan_change',
        'reminderEmailSent' => 'reminder_email_sent',
        'subscriptionDiscounts' => 'subscription_discounts',
        'pendingChange' => 'pending_change',
        'subscriptionChanges' => 'subscription_changes',
        'subscriptionAddOns' => 'subscription_add_ons',
        'activePaymentMethods' => 'active_payment_methods',
        'meteredBillingProducts' => 'metered_billing_products'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'handle' => 'setHandle',
        'customer' => 'setCustomer',
        'plan' => 'setPlan',
        'state' => 'setState',
        'test' => 'setTest',
        'quantity' => 'setQuantity',
        'timezone' => 'setTimezone',
        'created' => 'setCreated',
        'renewing' => 'setRenewing',
        'currency' => 'setCurrency',
        'planVersion' => 'setPlanVersion',
        'startDate' => 'setStartDate',
        'isCancelled' => 'setIsCancelled',
        'inTrial' => 'setInTrial',
        'hasStarted' => 'setHasStarted',
        'renewalCount' => 'setRenewalCount',
        'paymentMethodAdded' => 'setPaymentMethodAdded',
        'failedInvoices' => 'setFailedInvoices',
        'failedAmount' => 'setFailedAmount',
        'cancelledInvoices' => 'setCancelledInvoices',
        'cancelledAmount' => 'setCancelledAmount',
        'pendingInvoices' => 'setPendingInvoices',
        'pendingAmount' => 'setPendingAmount',
        'dunningInvoices' => 'setDunningInvoices',
        'dunningAmount' => 'setDunningAmount',
        'settledInvoices' => 'setSettledInvoices',
        'settledAmount' => 'setSettledAmount',
        'refundedAmount' => 'setRefundedAmount',
        'pendingAdditionalCosts' => 'setPendingAdditionalCosts',
        'pendingAdditionalCostAmount' => 'setPendingAdditionalCostAmount',
        'transferredAdditionalCosts' => 'setTransferredAdditionalCosts',
        'transferredAdditionalCostAmount' => 'setTransferredAdditionalCostAmount',
        'pendingCredits' => 'setPendingCredits',
        'pendingCreditAmount' => 'setPendingCreditAmount',
        'transferredCredits' => 'setTransferredCredits',
        'transferredCreditAmount' => 'setTransferredCreditAmount',
        'hostedPageLinks' => 'setHostedPageLinks',
        'amount' => 'setAmount',
        'expires' => 'setExpires',
        'reactivated' => 'setReactivated',
        'activated' => 'setActivated',
        'coupons' => 'setCoupons',
        'amountInclVat' => 'setAmountInclVat',
        'endDate' => 'setEndDate',
        'graceDuration' => 'setGraceDuration',
        'currentPeriodStart' => 'setCurrentPeriodStart',
        'nextPeriodStart' => 'setNextPeriodStart',
        'firstPeriodStart' => 'setFirstPeriodStart',
        'lastPeriodStart' => 'setLastPeriodStart',
        'trialStart' => 'setTrialStart',
        'trialEnd' => 'setTrialEnd',
        'cancelledDate' => 'setCancelledDate',
        'expiredDate' => 'setExpiredDate',
        'expireReason' => 'setExpireReason',
        'onHoldDate' => 'setOnHoldDate',
        'onHoldReason' => 'setOnHoldReason',
        'scheduledPlanChange' => 'setScheduledPlanChange',
        'reminderEmailSent' => 'setReminderEmailSent',
        'subscriptionDiscounts' => 'setSubscriptionDiscounts',
        'pendingChange' => 'setPendingChange',
        'subscriptionChanges' => 'setSubscriptionChanges',
        'subscriptionAddOns' => 'setSubscriptionAddOns',
        'activePaymentMethods' => 'setActivePaymentMethods',
        'meteredBillingProducts' => 'setMeteredBillingProducts'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'handle' => 'getHandle',
        'customer' => 'getCustomer',
        'plan' => 'getPlan',
        'state' => 'getState',
        'test' => 'getTest',
        'quantity' => 'getQuantity',
        'timezone' => 'getTimezone',
        'created' => 'getCreated',
        'renewing' => 'getRenewing',
        'currency' => 'getCurrency',
        'planVersion' => 'getPlanVersion',
        'startDate' => 'getStartDate',
        'isCancelled' => 'getIsCancelled',
        'inTrial' => 'getInTrial',
        'hasStarted' => 'getHasStarted',
        'renewalCount' => 'getRenewalCount',
        'paymentMethodAdded' => 'getPaymentMethodAdded',
        'failedInvoices' => 'getFailedInvoices',
        'failedAmount' => 'getFailedAmount',
        'cancelledInvoices' => 'getCancelledInvoices',
        'cancelledAmount' => 'getCancelledAmount',
        'pendingInvoices' => 'getPendingInvoices',
        'pendingAmount' => 'getPendingAmount',
        'dunningInvoices' => 'getDunningInvoices',
        'dunningAmount' => 'getDunningAmount',
        'settledInvoices' => 'getSettledInvoices',
        'settledAmount' => 'getSettledAmount',
        'refundedAmount' => 'getRefundedAmount',
        'pendingAdditionalCosts' => 'getPendingAdditionalCosts',
        'pendingAdditionalCostAmount' => 'getPendingAdditionalCostAmount',
        'transferredAdditionalCosts' => 'getTransferredAdditionalCosts',
        'transferredAdditionalCostAmount' => 'getTransferredAdditionalCostAmount',
        'pendingCredits' => 'getPendingCredits',
        'pendingCreditAmount' => 'getPendingCreditAmount',
        'transferredCredits' => 'getTransferredCredits',
        'transferredCreditAmount' => 'getTransferredCreditAmount',
        'hostedPageLinks' => 'getHostedPageLinks',
        'amount' => 'getAmount',
        'expires' => 'getExpires',
        'reactivated' => 'getReactivated',
        'activated' => 'getActivated',
        'coupons' => 'getCoupons',
        'amountInclVat' => 'getAmountInclVat',
        'endDate' => 'getEndDate',
        'graceDuration' => 'getGraceDuration',
        'currentPeriodStart' => 'getCurrentPeriodStart',
        'nextPeriodStart' => 'getNextPeriodStart',
        'firstPeriodStart' => 'getFirstPeriodStart',
        'lastPeriodStart' => 'getLastPeriodStart',
        'trialStart' => 'getTrialStart',
        'trialEnd' => 'getTrialEnd',
        'cancelledDate' => 'getCancelledDate',
        'expiredDate' => 'getExpiredDate',
        'expireReason' => 'getExpireReason',
        'onHoldDate' => 'getOnHoldDate',
        'onHoldReason' => 'getOnHoldReason',
        'scheduledPlanChange' => 'getScheduledPlanChange',
        'reminderEmailSent' => 'getReminderEmailSent',
        'subscriptionDiscounts' => 'getSubscriptionDiscounts',
        'pendingChange' => 'getPendingChange',
        'subscriptionChanges' => 'getSubscriptionChanges',
        'subscriptionAddOns' => 'getSubscriptionAddOns',
        'activePaymentMethods' => 'getActivePaymentMethods',
        'meteredBillingProducts' => 'getMeteredBillingProducts'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const STATE_ACTIVE = 'active';
    public const STATE_EXPIRED = 'expired';
    public const STATE_ON_HOLD = 'on_hold';
    public const STATE_PENDING = 'pending';
    public const STATE_UNKNOWN_DEFAULT_OPEN_API = 'unknown_default_open_api';
    public const EXPIRE_REASON_DUNNING = 'dunning';
    public const EXPIRE_REASON_CANCELLED = 'cancelled';
    public const EXPIRE_REASON_ONDEMAND = 'ondemand';
    public const EXPIRE_REASON_FIXED = 'fixed';
    public const EXPIRE_REASON_UNKNOWN_DEFAULT_OPEN_API = 'unknown_default_open_api';
    public const ON_HOLD_REASON_DUNNING = 'dunning';
    public const ON_HOLD_REASON_ONDEMAND = 'ondemand';
    public const ON_HOLD_REASON_UNKNOWN_DEFAULT_OPEN_API = 'unknown_default_open_api';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStateAllowableValues()
    {
        return [
            self::STATE_ACTIVE,
            self::STATE_EXPIRED,
            self::STATE_ON_HOLD,
            self::STATE_PENDING,
            self::STATE_UNKNOWN_DEFAULT_OPEN_API,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getExpireReasonAllowableValues()
    {
        return [
            self::EXPIRE_REASON_DUNNING,
            self::EXPIRE_REASON_CANCELLED,
            self::EXPIRE_REASON_ONDEMAND,
            self::EXPIRE_REASON_FIXED,
            self::EXPIRE_REASON_UNKNOWN_DEFAULT_OPEN_API,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getOnHoldReasonAllowableValues()
    {
        return [
            self::ON_HOLD_REASON_DUNNING,
            self::ON_HOLD_REASON_ONDEMAND,
            self::ON_HOLD_REASON_UNKNOWN_DEFAULT_OPEN_API,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('handle', $data ?? [], null);
        $this->setIfExists('customer', $data ?? [], null);
        $this->setIfExists('plan', $data ?? [], null);
        $this->setIfExists('state', $data ?? [], null);
        $this->setIfExists('test', $data ?? [], null);
        $this->setIfExists('quantity', $data ?? [], null);
        $this->setIfExists('timezone', $data ?? [], null);
        $this->setIfExists('created', $data ?? [], null);
        $this->setIfExists('renewing', $data ?? [], null);
        $this->setIfExists('currency', $data ?? [], null);
        $this->setIfExists('planVersion', $data ?? [], null);
        $this->setIfExists('startDate', $data ?? [], null);
        $this->setIfExists('isCancelled', $data ?? [], null);
        $this->setIfExists('inTrial', $data ?? [], null);
        $this->setIfExists('hasStarted', $data ?? [], null);
        $this->setIfExists('renewalCount', $data ?? [], null);
        $this->setIfExists('paymentMethodAdded', $data ?? [], null);
        $this->setIfExists('failedInvoices', $data ?? [], null);
        $this->setIfExists('failedAmount', $data ?? [], null);
        $this->setIfExists('cancelledInvoices', $data ?? [], null);
        $this->setIfExists('cancelledAmount', $data ?? [], null);
        $this->setIfExists('pendingInvoices', $data ?? [], null);
        $this->setIfExists('pendingAmount', $data ?? [], null);
        $this->setIfExists('dunningInvoices', $data ?? [], null);
        $this->setIfExists('dunningAmount', $data ?? [], null);
        $this->setIfExists('settledInvoices', $data ?? [], null);
        $this->setIfExists('settledAmount', $data ?? [], null);
        $this->setIfExists('refundedAmount', $data ?? [], null);
        $this->setIfExists('pendingAdditionalCosts', $data ?? [], null);
        $this->setIfExists('pendingAdditionalCostAmount', $data ?? [], null);
        $this->setIfExists('transferredAdditionalCosts', $data ?? [], null);
        $this->setIfExists('transferredAdditionalCostAmount', $data ?? [], null);
        $this->setIfExists('pendingCredits', $data ?? [], null);
        $this->setIfExists('pendingCreditAmount', $data ?? [], null);
        $this->setIfExists('transferredCredits', $data ?? [], null);
        $this->setIfExists('transferredCreditAmount', $data ?? [], null);
        $this->setIfExists('hostedPageLinks', $data ?? [], null);
        $this->setIfExists('amount', $data ?? [], null);
        $this->setIfExists('expires', $data ?? [], null);
        $this->setIfExists('reactivated', $data ?? [], null);
        $this->setIfExists('activated', $data ?? [], null);
        $this->setIfExists('coupons', $data ?? [], null);
        $this->setIfExists('amountInclVat', $data ?? [], null);
        $this->setIfExists('endDate', $data ?? [], null);
        $this->setIfExists('graceDuration', $data ?? [], null);
        $this->setIfExists('currentPeriodStart', $data ?? [], null);
        $this->setIfExists('nextPeriodStart', $data ?? [], null);
        $this->setIfExists('firstPeriodStart', $data ?? [], null);
        $this->setIfExists('lastPeriodStart', $data ?? [], null);
        $this->setIfExists('trialStart', $data ?? [], null);
        $this->setIfExists('trialEnd', $data ?? [], null);
        $this->setIfExists('cancelledDate', $data ?? [], null);
        $this->setIfExists('expiredDate', $data ?? [], null);
        $this->setIfExists('expireReason', $data ?? [], null);
        $this->setIfExists('onHoldDate', $data ?? [], null);
        $this->setIfExists('onHoldReason', $data ?? [], null);
        $this->setIfExists('scheduledPlanChange', $data ?? [], null);
        $this->setIfExists('reminderEmailSent', $data ?? [], null);
        $this->setIfExists('subscriptionDiscounts', $data ?? [], null);
        $this->setIfExists('pendingChange', $data ?? [], null);
        $this->setIfExists('subscriptionChanges', $data ?? [], null);
        $this->setIfExists('subscriptionAddOns', $data ?? [], null);
        $this->setIfExists('activePaymentMethods', $data ?? [], null);
        $this->setIfExists('meteredBillingProducts', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['handle'] === null) {
            $invalidProperties[] = "'handle' can't be null";
        }
        if ((mb_strlen($this->container['handle']) < 1)) {
            $invalidProperties[] = "invalid value for 'handle', the character length must be bigger than or equal to 1.";
        }

        if ($this->container['customer'] === null) {
            $invalidProperties[] = "'customer' can't be null";
        }
        if ((mb_strlen($this->container['customer']) < 1)) {
            $invalidProperties[] = "invalid value for 'customer', the character length must be bigger than or equal to 1.";
        }

        if ($this->container['plan'] === null) {
            $invalidProperties[] = "'plan' can't be null";
        }
        if ((mb_strlen($this->container['plan']) < 1)) {
            $invalidProperties[] = "invalid value for 'plan', the character length must be bigger than or equal to 1.";
        }

        if ($this->container['state'] === null) {
            $invalidProperties[] = "'state' can't be null";
        }
        $allowedValues = $this->getStateAllowableValues();
        if (!is_null($this->container['state']) && !in_array($this->container['state'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'state', must be one of '%s'",
                $this->container['state'],
                implode("', '", $allowedValues)
            );
        }

        if ((mb_strlen($this->container['state']) < 1)) {
            $invalidProperties[] = "invalid value for 'state', the character length must be bigger than or equal to 1.";
        }

        if ($this->container['test'] === null) {
            $invalidProperties[] = "'test' can't be null";
        }
        if ($this->container['quantity'] === null) {
            $invalidProperties[] = "'quantity' can't be null";
        }
        if ($this->container['timezone'] === null) {
            $invalidProperties[] = "'timezone' can't be null";
        }
        if ((mb_strlen($this->container['timezone']) < 1)) {
            $invalidProperties[] = "invalid value for 'timezone', the character length must be bigger than or equal to 1.";
        }

        if ($this->container['created'] === null) {
            $invalidProperties[] = "'created' can't be null";
        }
        if ($this->container['renewing'] === null) {
            $invalidProperties[] = "'renewing' can't be null";
        }
        if ($this->container['currency'] === null) {
            $invalidProperties[] = "'currency' can't be null";
        }
        if ((mb_strlen($this->container['currency']) < 1)) {
            $invalidProperties[] = "invalid value for 'currency', the character length must be bigger than or equal to 1.";
        }

        if ($this->container['planVersion'] === null) {
            $invalidProperties[] = "'planVersion' can't be null";
        }
        if ($this->container['startDate'] === null) {
            $invalidProperties[] = "'startDate' can't be null";
        }
        if ($this->container['isCancelled'] === null) {
            $invalidProperties[] = "'isCancelled' can't be null";
        }
        if ($this->container['inTrial'] === null) {
            $invalidProperties[] = "'inTrial' can't be null";
        }
        if ($this->container['hasStarted'] === null) {
            $invalidProperties[] = "'hasStarted' can't be null";
        }
        if ($this->container['renewalCount'] === null) {
            $invalidProperties[] = "'renewalCount' can't be null";
        }
        if (($this->container['renewalCount'] < 0)) {
            $invalidProperties[] = "invalid value for 'renewalCount', must be bigger than or equal to 0.";
        }

        if ($this->container['paymentMethodAdded'] === null) {
            $invalidProperties[] = "'paymentMethodAdded' can't be null";
        }
        if ($this->container['failedInvoices'] === null) {
            $invalidProperties[] = "'failedInvoices' can't be null";
        }
        if ($this->container['failedAmount'] === null) {
            $invalidProperties[] = "'failedAmount' can't be null";
        }
        if ($this->container['cancelledInvoices'] === null) {
            $invalidProperties[] = "'cancelledInvoices' can't be null";
        }
        if ($this->container['cancelledAmount'] === null) {
            $invalidProperties[] = "'cancelledAmount' can't be null";
        }
        if ($this->container['pendingInvoices'] === null) {
            $invalidProperties[] = "'pendingInvoices' can't be null";
        }
        if ($this->container['pendingAmount'] === null) {
            $invalidProperties[] = "'pendingAmount' can't be null";
        }
        if ($this->container['dunningInvoices'] === null) {
            $invalidProperties[] = "'dunningInvoices' can't be null";
        }
        if ($this->container['dunningAmount'] === null) {
            $invalidProperties[] = "'dunningAmount' can't be null";
        }
        if ($this->container['settledInvoices'] === null) {
            $invalidProperties[] = "'settledInvoices' can't be null";
        }
        if ($this->container['settledAmount'] === null) {
            $invalidProperties[] = "'settledAmount' can't be null";
        }
        if ($this->container['refundedAmount'] === null) {
            $invalidProperties[] = "'refundedAmount' can't be null";
        }
        if ($this->container['pendingAdditionalCosts'] === null) {
            $invalidProperties[] = "'pendingAdditionalCosts' can't be null";
        }
        if ($this->container['pendingAdditionalCostAmount'] === null) {
            $invalidProperties[] = "'pendingAdditionalCostAmount' can't be null";
        }
        if ($this->container['transferredAdditionalCosts'] === null) {
            $invalidProperties[] = "'transferredAdditionalCosts' can't be null";
        }
        if ($this->container['transferredAdditionalCostAmount'] === null) {
            $invalidProperties[] = "'transferredAdditionalCostAmount' can't be null";
        }
        if ($this->container['pendingCredits'] === null) {
            $invalidProperties[] = "'pendingCredits' can't be null";
        }
        if ($this->container['pendingCreditAmount'] === null) {
            $invalidProperties[] = "'pendingCreditAmount' can't be null";
        }
        if ($this->container['transferredCredits'] === null) {
            $invalidProperties[] = "'transferredCredits' can't be null";
        }
        if ($this->container['transferredCreditAmount'] === null) {
            $invalidProperties[] = "'transferredCreditAmount' can't be null";
        }
        if ($this->container['hostedPageLinks'] === null) {
            $invalidProperties[] = "'hostedPageLinks' can't be null";
        }
        $allowedValues = $this->getExpireReasonAllowableValues();
        if (!is_null($this->container['expireReason']) && !in_array($this->container['expireReason'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'expireReason', must be one of '%s'",
                $this->container['expireReason'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getOnHoldReasonAllowableValues();
        if (!is_null($this->container['onHoldReason']) && !in_array($this->container['onHoldReason'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'onHoldReason', must be one of '%s'",
                $this->container['onHoldReason'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets handle
     *
     * @return string
     */
    public function getHandle()
    {
        return $this->container['handle'];
    }

    /**
     * Sets handle
     *
     * @param string $handle Per account unique handle for subscription
     *
     * @return self
     */
    public function setHandle($handle)
    {
        if (is_null($handle)) {
            throw new \InvalidArgumentException('non-nullable handle cannot be null');
        }

        if ((mb_strlen($handle) < 1)) {
            throw new \InvalidArgumentException('invalid length for $handle when calling SubscriptionCancelPreview., must be bigger than or equal to 1.');
        }

        $this->container['handle'] = $handle;

        return $this;
    }

    /**
     * Gets customer
     *
     * @return string
     */
    public function getCustomer()
    {
        return $this->container['customer'];
    }

    /**
     * Sets customer
     *
     * @param string $customer Customer handle
     *
     * @return self
     */
    public function setCustomer($customer)
    {
        if (is_null($customer)) {
            throw new \InvalidArgumentException('non-nullable customer cannot be null');
        }

        if ((mb_strlen($customer) < 1)) {
            throw new \InvalidArgumentException('invalid length for $customer when calling SubscriptionCancelPreview., must be bigger than or equal to 1.');
        }

        $this->container['customer'] = $customer;

        return $this;
    }

    /**
     * Gets plan
     *
     * @return string
     */
    public function getPlan()
    {
        return $this->container['plan'];
    }

    /**
     * Sets plan
     *
     * @param string $plan Subscription plan handle
     *
     * @return self
     */
    public function setPlan($plan)
    {
        if (is_null($plan)) {
            throw new \InvalidArgumentException('non-nullable plan cannot be null');
        }

        if ((mb_strlen($plan) < 1)) {
            throw new \InvalidArgumentException('invalid length for $plan when calling SubscriptionCancelPreview., must be bigger than or equal to 1.');
        }

        $this->container['plan'] = $plan;

        return $this;
    }

    /**
     * Gets state
     *
     * @return string
     */
    public function getState()
    {
        return $this->container['state'];
    }

    /**
     * Sets state
     *
     * @param string $state State of the subscription, one of the following: `active`, `expired`, `on_hold` or `pending`. Active subscriptions can be cancelled and will expire at the end of the current billing period, or later depending on optional notice and fixation periods, this can be checked using the `is_cancelled` parameter and `expires`.
     *
     * @return self
     */
    public function setState($state)
    {
        if (is_null($state)) {
            throw new \InvalidArgumentException('non-nullable state cannot be null');
        }
        $allowedValues = $this->getStateAllowableValues();
        if (!in_array($state, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'state', must be one of '%s'",
                    $state,
                    implode("', '", $allowedValues)
                )
            );
        }

        if ((mb_strlen($state) < 1)) {
            throw new \InvalidArgumentException('invalid length for $state when calling SubscriptionCancelPreview., must be bigger than or equal to 1.');
        }

        $this->container['state'] = $state;

        return $this;
    }

    /**
     * Gets test
     *
     * @return bool
     */
    public function getTest()
    {
        return $this->container['test'];
    }

    /**
     * Sets test
     *
     * @param bool $test Test flag
     *
     * @return self
     */
    public function setTest($test)
    {
        if (is_null($test)) {
            throw new \InvalidArgumentException('non-nullable test cannot be null');
        }
        $this->container['test'] = $test;

        return $this;
    }

    /**
     * Gets quantity
     *
     * @return int
     */
    public function getQuantity()
    {
        return $this->container['quantity'];
    }

    /**
     * Sets quantity
     *
     * @param int $quantity Quantity of the plan product for this subscription.
     *
     * @return self
     */
    public function setQuantity($quantity)
    {
        if (is_null($quantity)) {
            throw new \InvalidArgumentException('non-nullable quantity cannot be null');
        }
        $this->container['quantity'] = $quantity;

        return $this;
    }

    /**
     * Gets timezone
     *
     * @return string
     */
    public function getTimezone()
    {
        return $this->container['timezone'];
    }

    /**
     * Sets timezone
     *
     * @param string $timezone Time zone for the subscription as standard time zone id. See [Wikipedia](http://en.wikipedia.org/wiki/List_of_tz_database_time_zones)
     *
     * @return self
     */
    public function setTimezone($timezone)
    {
        if (is_null($timezone)) {
            throw new \InvalidArgumentException('non-nullable timezone cannot be null');
        }

        if ((mb_strlen($timezone) < 1)) {
            throw new \InvalidArgumentException('invalid length for $timezone when calling SubscriptionCancelPreview., must be bigger than or equal to 1.');
        }

        $this->container['timezone'] = $timezone;

        return $this;
    }

    /**
     * Gets created
     *
     * @return \DateTime
     */
    public function getCreated()
    {
        return $this->container['created'];
    }

    /**
     * Sets created
     *
     * @param \DateTime $created Date when the subscription was created. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return self
     */
    public function setCreated($created)
    {
        if (is_null($created)) {
            throw new \InvalidArgumentException('non-nullable created cannot be null');
        }
        $this->container['created'] = $created;

        return $this;
    }

    /**
     * Gets renewing
     *
     * @return bool
     */
    public function getRenewing()
    {
        return $this->container['renewing'];
    }

    /**
     * Sets renewing
     *
     * @param bool $renewing If the subscription renews at current period end. Also true for subscriptions with manual scheduling.
     *
     * @return self
     */
    public function setRenewing($renewing)
    {
        if (is_null($renewing)) {
            throw new \InvalidArgumentException('non-nullable renewing cannot be null');
        }
        $this->container['renewing'] = $renewing;

        return $this;
    }

    /**
     * Gets currency
     *
     * @return string
     */
    public function getCurrency()
    {
        return $this->container['currency'];
    }

    /**
     * Sets currency
     *
     * @param string $currency Currency for the subscription in [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) three letter alpha code
     *
     * @return self
     */
    public function setCurrency($currency)
    {
        if (is_null($currency)) {
            throw new \InvalidArgumentException('non-nullable currency cannot be null');
        }

        if ((mb_strlen($currency) < 1)) {
            throw new \InvalidArgumentException('invalid length for $currency when calling SubscriptionCancelPreview., must be bigger than or equal to 1.');
        }

        $this->container['currency'] = $currency;

        return $this;
    }

    /**
     * Gets planVersion
     *
     * @return int
     */
    public function getPlanVersion()
    {
        return $this->container['planVersion'];
    }

    /**
     * Sets planVersion
     *
     * @param int $planVersion Subscription plan version
     *
     * @return self
     */
    public function setPlanVersion($planVersion)
    {
        if (is_null($planVersion)) {
            throw new \InvalidArgumentException('non-nullable planVersion cannot be null');
        }
        $this->container['planVersion'] = $planVersion;

        return $this;
    }

    /**
     * Gets startDate
     *
     * @return \DateTime
     */
    public function getStartDate()
    {
        return $this->container['startDate'];
    }

    /**
     * Sets startDate
     *
     * @param \DateTime $startDate Date and time from which the subscription is eligible to schedule invoices. Either from create or from the latest reactivate or subscription change. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return self
     */
    public function setStartDate($startDate)
    {
        if (is_null($startDate)) {
            throw new \InvalidArgumentException('non-nullable startDate cannot be null');
        }
        $this->container['startDate'] = $startDate;

        return $this;
    }

    /**
     * Gets isCancelled
     *
     * @return bool
     */
    public function getIsCancelled()
    {
        return $this->container['isCancelled'];
    }

    /**
     * Sets isCancelled
     *
     * @param bool $isCancelled Whether the subscription has been cancelled. Cancelled subscriptions will expire at the end of the current billing period.
     *
     * @return self
     */
    public function setIsCancelled($isCancelled)
    {
        if (is_null($isCancelled)) {
            throw new \InvalidArgumentException('non-nullable isCancelled cannot be null');
        }
        $this->container['isCancelled'] = $isCancelled;

        return $this;
    }

    /**
     * Gets inTrial
     *
     * @return bool
     */
    public function getInTrial()
    {
        return $this->container['inTrial'];
    }

    /**
     * Sets inTrial
     *
     * @param bool $inTrial Whether the subscription is in its trial period, or if the subscription will start a trial period at a start date in the future. See `has_started` to determine if the actual trial period has started or not.
     *
     * @return self
     */
    public function setInTrial($inTrial)
    {
        if (is_null($inTrial)) {
            throw new \InvalidArgumentException('non-nullable inTrial cannot be null');
        }
        $this->container['inTrial'] = $inTrial;

        return $this;
    }

    /**
     * Gets hasStarted
     *
     * @return bool
     */
    public function getHasStarted()
    {
        return $this->container['hasStarted'];
    }

    /**
     * Sets hasStarted
     *
     * @param bool $hasStarted If subscription has a later start date, this parameter tells if the subscription has started. Use this in connection with state to determine if a subscription is active.
     *
     * @return self
     */
    public function setHasStarted($hasStarted)
    {
        if (is_null($hasStarted)) {
            throw new \InvalidArgumentException('non-nullable hasStarted cannot be null');
        }
        $this->container['hasStarted'] = $hasStarted;

        return $this;
    }

    /**
     * Gets renewalCount
     *
     * @return int
     */
    public function getRenewalCount()
    {
        return $this->container['renewalCount'];
    }

    /**
     * Sets renewalCount
     *
     * @param int $renewalCount Number of renewals for the subscription (number of invoices)
     *
     * @return self
     */
    public function setRenewalCount($renewalCount)
    {
        if (is_null($renewalCount)) {
            throw new \InvalidArgumentException('non-nullable renewalCount cannot be null');
        }

        if (($renewalCount < 0)) {
            throw new \InvalidArgumentException('invalid value for $renewalCount when calling SubscriptionCancelPreview., must be bigger than or equal to 0.');
        }

        $this->container['renewalCount'] = $renewalCount;

        return $this;
    }

    /**
     * Gets paymentMethodAdded
     *
     * @return bool
     */
    public function getPaymentMethodAdded()
    {
        return $this->container['paymentMethodAdded'];
    }

    /**
     * Sets paymentMethodAdded
     *
     * @param bool $paymentMethodAdded Whether the customer at some point has added payment information to the subscription
     *
     * @return self
     */
    public function setPaymentMethodAdded($paymentMethodAdded)
    {
        if (is_null($paymentMethodAdded)) {
            throw new \InvalidArgumentException('non-nullable paymentMethodAdded cannot be null');
        }
        $this->container['paymentMethodAdded'] = $paymentMethodAdded;

        return $this;
    }

    /**
     * Gets failedInvoices
     *
     * @return int
     */
    public function getFailedInvoices()
    {
        return $this->container['failedInvoices'];
    }

    /**
     * Sets failedInvoices
     *
     * @param int $failedInvoices Number of failed invoices for this subscription
     *
     * @return self
     */
    public function setFailedInvoices($failedInvoices)
    {
        if (is_null($failedInvoices)) {
            throw new \InvalidArgumentException('non-nullable failedInvoices cannot be null');
        }
        $this->container['failedInvoices'] = $failedInvoices;

        return $this;
    }

    /**
     * Gets failedAmount
     *
     * @return int
     */
    public function getFailedAmount()
    {
        return $this->container['failedAmount'];
    }

    /**
     * Sets failedAmount
     *
     * @param int $failedAmount Summed amount for failed invoices
     *
     * @return self
     */
    public function setFailedAmount($failedAmount)
    {
        if (is_null($failedAmount)) {
            throw new \InvalidArgumentException('non-nullable failedAmount cannot be null');
        }
        $this->container['failedAmount'] = $failedAmount;

        return $this;
    }

    /**
     * Gets cancelledInvoices
     *
     * @return int
     */
    public function getCancelledInvoices()
    {
        return $this->container['cancelledInvoices'];
    }

    /**
     * Sets cancelledInvoices
     *
     * @param int $cancelledInvoices Number of cancelled invoices for this subscription
     *
     * @return self
     */
    public function setCancelledInvoices($cancelledInvoices)
    {
        if (is_null($cancelledInvoices)) {
            throw new \InvalidArgumentException('non-nullable cancelledInvoices cannot be null');
        }
        $this->container['cancelledInvoices'] = $cancelledInvoices;

        return $this;
    }

    /**
     * Gets cancelledAmount
     *
     * @return int
     */
    public function getCancelledAmount()
    {
        return $this->container['cancelledAmount'];
    }

    /**
     * Sets cancelledAmount
     *
     * @param int $cancelledAmount Summed amount for cancelled invoices
     *
     * @return self
     */
    public function setCancelledAmount($cancelledAmount)
    {
        if (is_null($cancelledAmount)) {
            throw new \InvalidArgumentException('non-nullable cancelledAmount cannot be null');
        }
        $this->container['cancelledAmount'] = $cancelledAmount;

        return $this;
    }

    /**
     * Gets pendingInvoices
     *
     * @return int
     */
    public function getPendingInvoices()
    {
        return $this->container['pendingInvoices'];
    }

    /**
     * Sets pendingInvoices
     *
     * @param int $pendingInvoices Number of pending invoices for this subscription
     *
     * @return self
     */
    public function setPendingInvoices($pendingInvoices)
    {
        if (is_null($pendingInvoices)) {
            throw new \InvalidArgumentException('non-nullable pendingInvoices cannot be null');
        }
        $this->container['pendingInvoices'] = $pendingInvoices;

        return $this;
    }

    /**
     * Gets pendingAmount
     *
     * @return int
     */
    public function getPendingAmount()
    {
        return $this->container['pendingAmount'];
    }

    /**
     * Sets pendingAmount
     *
     * @param int $pendingAmount Summed amount for pending invoices
     *
     * @return self
     */
    public function setPendingAmount($pendingAmount)
    {
        if (is_null($pendingAmount)) {
            throw new \InvalidArgumentException('non-nullable pendingAmount cannot be null');
        }
        $this->container['pendingAmount'] = $pendingAmount;

        return $this;
    }

    /**
     * Gets dunningInvoices
     *
     * @return int
     */
    public function getDunningInvoices()
    {
        return $this->container['dunningInvoices'];
    }

    /**
     * Sets dunningInvoices
     *
     * @param int $dunningInvoices Number of dunning invoices for this subscription
     *
     * @return self
     */
    public function setDunningInvoices($dunningInvoices)
    {
        if (is_null($dunningInvoices)) {
            throw new \InvalidArgumentException('non-nullable dunningInvoices cannot be null');
        }
        $this->container['dunningInvoices'] = $dunningInvoices;

        return $this;
    }

    /**
     * Gets dunningAmount
     *
     * @return int
     */
    public function getDunningAmount()
    {
        return $this->container['dunningAmount'];
    }

    /**
     * Sets dunningAmount
     *
     * @param int $dunningAmount Summed amount for dunning invoices
     *
     * @return self
     */
    public function setDunningAmount($dunningAmount)
    {
        if (is_null($dunningAmount)) {
            throw new \InvalidArgumentException('non-nullable dunningAmount cannot be null');
        }
        $this->container['dunningAmount'] = $dunningAmount;

        return $this;
    }

    /**
     * Gets settledInvoices
     *
     * @return int
     */
    public function getSettledInvoices()
    {
        return $this->container['settledInvoices'];
    }

    /**
     * Sets settledInvoices
     *
     * @param int $settledInvoices Number of settled invoices for this subscription
     *
     * @return self
     */
    public function setSettledInvoices($settledInvoices)
    {
        if (is_null($settledInvoices)) {
            throw new \InvalidArgumentException('non-nullable settledInvoices cannot be null');
        }
        $this->container['settledInvoices'] = $settledInvoices;

        return $this;
    }

    /**
     * Gets settledAmount
     *
     * @return int
     */
    public function getSettledAmount()
    {
        return $this->container['settledAmount'];
    }

    /**
     * Sets settledAmount
     *
     * @param int $settledAmount Summed settled amount
     *
     * @return self
     */
    public function setSettledAmount($settledAmount)
    {
        if (is_null($settledAmount)) {
            throw new \InvalidArgumentException('non-nullable settledAmount cannot be null');
        }
        $this->container['settledAmount'] = $settledAmount;

        return $this;
    }

    /**
     * Gets refundedAmount
     *
     * @return int
     */
    public function getRefundedAmount()
    {
        return $this->container['refundedAmount'];
    }

    /**
     * Sets refundedAmount
     *
     * @param int $refundedAmount Summed refunded amount
     *
     * @return self
     */
    public function setRefundedAmount($refundedAmount)
    {
        if (is_null($refundedAmount)) {
            throw new \InvalidArgumentException('non-nullable refundedAmount cannot be null');
        }
        $this->container['refundedAmount'] = $refundedAmount;

        return $this;
    }

    /**
     * Gets pendingAdditionalCosts
     *
     * @return int
     */
    public function getPendingAdditionalCosts()
    {
        return $this->container['pendingAdditionalCosts'];
    }

    /**
     * Sets pendingAdditionalCosts
     *
     * @param int $pendingAdditionalCosts Number of pending additional costs
     *
     * @return self
     */
    public function setPendingAdditionalCosts($pendingAdditionalCosts)
    {
        if (is_null($pendingAdditionalCosts)) {
            throw new \InvalidArgumentException('non-nullable pendingAdditionalCosts cannot be null');
        }
        $this->container['pendingAdditionalCosts'] = $pendingAdditionalCosts;

        return $this;
    }

    /**
     * Gets pendingAdditionalCostAmount
     *
     * @return int
     */
    public function getPendingAdditionalCostAmount()
    {
        return $this->container['pendingAdditionalCostAmount'];
    }

    /**
     * Sets pendingAdditionalCostAmount
     *
     * @param int $pendingAdditionalCostAmount Summed amount of pending additional costs incl vat
     *
     * @return self
     */
    public function setPendingAdditionalCostAmount($pendingAdditionalCostAmount)
    {
        if (is_null($pendingAdditionalCostAmount)) {
            throw new \InvalidArgumentException('non-nullable pendingAdditionalCostAmount cannot be null');
        }
        $this->container['pendingAdditionalCostAmount'] = $pendingAdditionalCostAmount;

        return $this;
    }

    /**
     * Gets transferredAdditionalCosts
     *
     * @return int
     */
    public function getTransferredAdditionalCosts()
    {
        return $this->container['transferredAdditionalCosts'];
    }

    /**
     * Sets transferredAdditionalCosts
     *
     * @param int $transferredAdditionalCosts Number of additional costs that have been applied to invoices
     *
     * @return self
     */
    public function setTransferredAdditionalCosts($transferredAdditionalCosts)
    {
        if (is_null($transferredAdditionalCosts)) {
            throw new \InvalidArgumentException('non-nullable transferredAdditionalCosts cannot be null');
        }
        $this->container['transferredAdditionalCosts'] = $transferredAdditionalCosts;

        return $this;
    }

    /**
     * Gets transferredAdditionalCostAmount
     *
     * @return int
     */
    public function getTransferredAdditionalCostAmount()
    {
        return $this->container['transferredAdditionalCostAmount'];
    }

    /**
     * Sets transferredAdditionalCostAmount
     *
     * @param int $transferredAdditionalCostAmount Summed amount of additional costs that have been applied to invoices
     *
     * @return self
     */
    public function setTransferredAdditionalCostAmount($transferredAdditionalCostAmount)
    {
        if (is_null($transferredAdditionalCostAmount)) {
            throw new \InvalidArgumentException('non-nullable transferredAdditionalCostAmount cannot be null');
        }
        $this->container['transferredAdditionalCostAmount'] = $transferredAdditionalCostAmount;

        return $this;
    }

    /**
     * Gets pendingCredits
     *
     * @return int
     */
    public function getPendingCredits()
    {
        return $this->container['pendingCredits'];
    }

    /**
     * Sets pendingCredits
     *
     * @param int $pendingCredits Number of credits that have not fully been applied to invoices
     *
     * @return self
     */
    public function setPendingCredits($pendingCredits)
    {
        if (is_null($pendingCredits)) {
            throw new \InvalidArgumentException('non-nullable pendingCredits cannot be null');
        }
        $this->container['pendingCredits'] = $pendingCredits;

        return $this;
    }

    /**
     * Gets pendingCreditAmount
     *
     * @return int
     */
    public function getPendingCreditAmount()
    {
        return $this->container['pendingCreditAmount'];
    }

    /**
     * Sets pendingCreditAmount
     *
     * @param int $pendingCreditAmount Summed credit amount not yet applied to invoices
     *
     * @return self
     */
    public function setPendingCreditAmount($pendingCreditAmount)
    {
        if (is_null($pendingCreditAmount)) {
            throw new \InvalidArgumentException('non-nullable pendingCreditAmount cannot be null');
        }
        $this->container['pendingCreditAmount'] = $pendingCreditAmount;

        return $this;
    }

    /**
     * Gets transferredCredits
     *
     * @return int
     */
    public function getTransferredCredits()
    {
        return $this->container['transferredCredits'];
    }

    /**
     * Sets transferredCredits
     *
     * @param int $transferredCredits Number of credits that have fully been applied to invoices
     *
     * @return self
     */
    public function setTransferredCredits($transferredCredits)
    {
        if (is_null($transferredCredits)) {
            throw new \InvalidArgumentException('non-nullable transferredCredits cannot be null');
        }
        $this->container['transferredCredits'] = $transferredCredits;

        return $this;
    }

    /**
     * Gets transferredCreditAmount
     *
     * @return int
     */
    public function getTransferredCreditAmount()
    {
        return $this->container['transferredCreditAmount'];
    }

    /**
     * Sets transferredCreditAmount
     *
     * @param int $transferredCreditAmount Summed credit amount that have been applied to invoices
     *
     * @return self
     */
    public function setTransferredCreditAmount($transferredCreditAmount)
    {
        if (is_null($transferredCreditAmount)) {
            throw new \InvalidArgumentException('non-nullable transferredCreditAmount cannot be null');
        }
        $this->container['transferredCreditAmount'] = $transferredCreditAmount;

        return $this;
    }

    /**
     * Gets hostedPageLinks
     *
     * @return \Frisbii\Model\SubscriptionLinks
     */
    public function getHostedPageLinks()
    {
        return $this->container['hostedPageLinks'];
    }

    /**
     * Sets hostedPageLinks
     *
     * @param \Frisbii\Model\SubscriptionLinks $hostedPageLinks hostedPageLinks
     *
     * @return self
     */
    public function setHostedPageLinks($hostedPageLinks)
    {
        if (is_null($hostedPageLinks)) {
            throw new \InvalidArgumentException('non-nullable hostedPageLinks cannot be null');
        }
        $this->container['hostedPageLinks'] = $hostedPageLinks;

        return $this;
    }

    /**
     * Gets amount
     *
     * @return int|null
     */
    public function getAmount()
    {
        return $this->container['amount'];
    }

    /**
     * Sets amount
     *
     * @param int|null $amount Optional custom plan price. If defined the plan price billed for each billing period will be overridden by this price.
     *
     * @return self
     */
    public function setAmount($amount)
    {
        if (is_null($amount)) {
            throw new \InvalidArgumentException('non-nullable amount cannot be null');
        }
        $this->container['amount'] = $amount;

        return $this;
    }

    /**
     * Gets expires
     *
     * @return \DateTime|null
     */
    public function getExpires()
    {
        return $this->container['expires'];
    }

    /**
     * Sets expires
     *
     * @param \DateTime|null $expires Fixed date when the subscription will expire because of cancellation. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return self
     */
    public function setExpires($expires)
    {
        if (is_null($expires)) {
            throw new \InvalidArgumentException('non-nullable expires cannot be null');
        }
        $this->container['expires'] = $expires;

        return $this;
    }

    /**
     * Gets reactivated
     *
     * @return \DateTime|null
     */
    public function getReactivated()
    {
        return $this->container['reactivated'];
    }

    /**
     * Sets reactivated
     *
     * @param \DateTime|null $reactivated Date when the subscription was reactivated from on hold. [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return self
     */
    public function setReactivated($reactivated)
    {
        if (is_null($reactivated)) {
            throw new \InvalidArgumentException('non-nullable reactivated cannot be null');
        }
        $this->container['reactivated'] = $reactivated;

        return $this;
    }

    /**
     * Gets activated
     *
     * @return \DateTime|null
     */
    public function getActivated()
    {
        return $this->container['activated'];
    }

    /**
     * Sets activated
     *
     * @param \DateTime|null $activated Date when the subscription was activated. Will only differ from created in a two step prepared -> activated subscription create scenario. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return self
     */
    public function setActivated($activated)
    {
        if (is_null($activated)) {
            throw new \InvalidArgumentException('non-nullable activated cannot be null');
        }
        $this->container['activated'] = $activated;

        return $this;
    }

    /**
     * Gets coupons
     *
     * @return string[]|null
     */
    public function getCoupons()
    {
        return $this->container['coupons'];
    }

    /**
     * Sets coupons
     *
     * @param string[]|null $coupons List of coupon handles redeemed for the subscription
     *
     * @return self
     */
    public function setCoupons($coupons)
    {
        if (is_null($coupons)) {
            throw new \InvalidArgumentException('non-nullable coupons cannot be null');
        }
        $this->container['coupons'] = $coupons;

        return $this;
    }

    /**
     * Gets amountInclVat
     *
     * @return bool|null
     */
    public function getAmountInclVat()
    {
        return $this->container['amountInclVat'];
    }

    /**
     * Sets amountInclVat
     *
     * @param bool|null $amountInclVat If optional custom plan price this parameter tells whether the amount is including VAT
     *
     * @return self
     */
    public function setAmountInclVat($amountInclVat)
    {
        if (is_null($amountInclVat)) {
            throw new \InvalidArgumentException('non-nullable amountInclVat cannot be null');
        }
        $this->container['amountInclVat'] = $amountInclVat;

        return $this;
    }

    /**
     * Gets endDate
     *
     * @return \DateTime|null
     */
    public function getEndDate()
    {
        return $this->container['endDate'];
    }

    /**
     * Sets endDate
     *
     * @param \DateTime|null $endDate Fixed end date and time. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return self
     */
    public function setEndDate($endDate)
    {
        if (is_null($endDate)) {
            throw new \InvalidArgumentException('non-nullable endDate cannot be null');
        }
        $this->container['endDate'] = $endDate;

        return $this;
    }

    /**
     * Gets graceDuration
     *
     * @return int|null
     */
    public function getGraceDuration()
    {
        return $this->container['graceDuration'];
    }

    /**
     * Sets graceDuration
     *
     * @param int|null $graceDuration Grace duration in seconds from the creation of a subscription where no dunning process is started for a failing invoice. This allows a certain amount of time for the customer to sign up with a payment method.
     *
     * @return self
     */
    public function setGraceDuration($graceDuration)
    {
        if (is_null($graceDuration)) {
            throw new \InvalidArgumentException('non-nullable graceDuration cannot be null');
        }
        $this->container['graceDuration'] = $graceDuration;

        return $this;
    }

    /**
     * Gets currentPeriodStart
     *
     * @return \DateTime|null
     */
    public function getCurrentPeriodStart()
    {
        return $this->container['currentPeriodStart'];
    }

    /**
     * Sets currentPeriodStart
     *
     * @param \DateTime|null $currentPeriodStart Start date and time for the current billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return self
     */
    public function setCurrentPeriodStart($currentPeriodStart)
    {
        if (is_null($currentPeriodStart)) {
            throw new \InvalidArgumentException('non-nullable currentPeriodStart cannot be null');
        }
        $this->container['currentPeriodStart'] = $currentPeriodStart;

        return $this;
    }

    /**
     * Gets nextPeriodStart
     *
     * @return \DateTime|null
     */
    public function getNextPeriodStart()
    {
        return $this->container['nextPeriodStart'];
    }

    /**
     * Sets nextPeriodStart
     *
     * @param \DateTime|null $nextPeriodStart Start date and time for the next billing period, and also end date and time for the current billing period. Is also the date and time for next invoice if the subscription is renewing. In ISO-8601 extended offset date-time format.
     *
     * @return self
     */
    public function setNextPeriodStart($nextPeriodStart)
    {
        if (is_null($nextPeriodStart)) {
            throw new \InvalidArgumentException('non-nullable nextPeriodStart cannot be null');
        }
        $this->container['nextPeriodStart'] = $nextPeriodStart;

        return $this;
    }

    /**
     * Gets firstPeriodStart
     *
     * @return \DateTime|null
     */
    public function getFirstPeriodStart()
    {
        return $this->container['firstPeriodStart'];
    }

    /**
     * Sets firstPeriodStart
     *
     * @param \DateTime|null $firstPeriodStart Start date and time for the first ever billing period. In ISO-8601 extended offset date-time format.
     *
     * @return self
     */
    public function setFirstPeriodStart($firstPeriodStart)
    {
        if (is_null($firstPeriodStart)) {
            throw new \InvalidArgumentException('non-nullable firstPeriodStart cannot be null');
        }
        $this->container['firstPeriodStart'] = $firstPeriodStart;

        return $this;
    }

    /**
     * Gets lastPeriodStart
     *
     * @return \DateTime|null
     */
    public function getLastPeriodStart()
    {
        return $this->container['lastPeriodStart'];
    }

    /**
     * Sets lastPeriodStart
     *
     * @param \DateTime|null $lastPeriodStart Start date and time for the previous billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return self
     */
    public function setLastPeriodStart($lastPeriodStart)
    {
        if (is_null($lastPeriodStart)) {
            throw new \InvalidArgumentException('non-nullable lastPeriodStart cannot be null');
        }
        $this->container['lastPeriodStart'] = $lastPeriodStart;

        return $this;
    }

    /**
     * Gets trialStart
     *
     * @return \DateTime|null
     */
    public function getTrialStart()
    {
        return $this->container['trialStart'];
    }

    /**
     * Sets trialStart
     *
     * @param \DateTime|null $trialStart Start date and time of free trial period. In ISO-8601 extended offset date-time format.
     *
     * @return self
     */
    public function setTrialStart($trialStart)
    {
        if (is_null($trialStart)) {
            throw new \InvalidArgumentException('non-nullable trialStart cannot be null');
        }
        $this->container['trialStart'] = $trialStart;

        return $this;
    }

    /**
     * Gets trialEnd
     *
     * @return \DateTime|null
     */
    public function getTrialEnd()
    {
        return $this->container['trialEnd'];
    }

    /**
     * Sets trialEnd
     *
     * @param \DateTime|null $trialEnd End date and time of free trial period. In ISO-8601 extended offset date-time format.
     *
     * @return self
     */
    public function setTrialEnd($trialEnd)
    {
        if (is_null($trialEnd)) {
            throw new \InvalidArgumentException('non-nullable trialEnd cannot be null');
        }
        $this->container['trialEnd'] = $trialEnd;

        return $this;
    }

    /**
     * Gets cancelledDate
     *
     * @return \DateTime|null
     */
    public function getCancelledDate()
    {
        return $this->container['cancelledDate'];
    }

    /**
     * Sets cancelledDate
     *
     * @param \DateTime|null $cancelledDate Date when the subscription was cancelled. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return self
     */
    public function setCancelledDate($cancelledDate)
    {
        if (is_null($cancelledDate)) {
            throw new \InvalidArgumentException('non-nullable cancelledDate cannot be null');
        }
        $this->container['cancelledDate'] = $cancelledDate;

        return $this;
    }

    /**
     * Gets expiredDate
     *
     * @return \DateTime|null
     */
    public function getExpiredDate()
    {
        return $this->container['expiredDate'];
    }

    /**
     * Sets expiredDate
     *
     * @param \DateTime|null $expiredDate Date when the subscription expired. [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return self
     */
    public function setExpiredDate($expiredDate)
    {
        if (is_null($expiredDate)) {
            throw new \InvalidArgumentException('non-nullable expiredDate cannot be null');
        }
        $this->container['expiredDate'] = $expiredDate;

        return $this;
    }

    /**
     * Gets expireReason
     *
     * @return string|null
     */
    public function getExpireReason()
    {
        return $this->container['expireReason'];
    }

    /**
     * Sets expireReason
     *
     * @param string|null $expireReason Reason for expire. Can be `ondemand`, `cancelled`, `dunning` or `fixed`
     *
     * @return self
     */
    public function setExpireReason($expireReason)
    {
        if (is_null($expireReason)) {
            throw new \InvalidArgumentException('non-nullable expireReason cannot be null');
        }
        $allowedValues = $this->getExpireReasonAllowableValues();
        if (!in_array($expireReason, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'expireReason', must be one of '%s'",
                    $expireReason,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['expireReason'] = $expireReason;

        return $this;
    }

    /**
     * Gets onHoldDate
     *
     * @return \DateTime|null
     */
    public function getOnHoldDate()
    {
        return $this->container['onHoldDate'];
    }

    /**
     * Sets onHoldDate
     *
     * @param \DateTime|null $onHoldDate Date when the subscription was put on hold. [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return self
     */
    public function setOnHoldDate($onHoldDate)
    {
        if (is_null($onHoldDate)) {
            throw new \InvalidArgumentException('non-nullable onHoldDate cannot be null');
        }
        $this->container['onHoldDate'] = $onHoldDate;

        return $this;
    }

    /**
     * Gets onHoldReason
     *
     * @return string|null
     */
    public function getOnHoldReason()
    {
        return $this->container['onHoldReason'];
    }

    /**
     * Sets onHoldReason
     *
     * @param string|null $onHoldReason Reason for on hold. Can be `ondemand` or `dunning`
     *
     * @return self
     */
    public function setOnHoldReason($onHoldReason)
    {
        if (is_null($onHoldReason)) {
            throw new \InvalidArgumentException('non-nullable onHoldReason cannot be null');
        }
        $allowedValues = $this->getOnHoldReasonAllowableValues();
        if (!in_array($onHoldReason, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'onHoldReason', must be one of '%s'",
                    $onHoldReason,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['onHoldReason'] = $onHoldReason;

        return $this;
    }

    /**
     * Gets scheduledPlanChange
     *
     * @return string|null
     */
    public function getScheduledPlanChange()
    {
        return $this->container['scheduledPlanChange'];
    }

    /**
     * Sets scheduledPlanChange
     *
     * @param string|null $scheduledPlanChange Deprecated - see `pending_change`. If set, a subscription plan change has been scheduled to follow the next renewal. The value is the subscription plan handle to update to.
     *
     * @return self
     */
    public function setScheduledPlanChange($scheduledPlanChange)
    {
        if (is_null($scheduledPlanChange)) {
            throw new \InvalidArgumentException('non-nullable scheduledPlanChange cannot be null');
        }
        $this->container['scheduledPlanChange'] = $scheduledPlanChange;

        return $this;
    }

    /**
     * Gets reminderEmailSent
     *
     * @return \DateTime|null
     */
    public function getReminderEmailSent()
    {
        return $this->container['reminderEmailSent'];
    }

    /**
     * Sets reminderEmailSent
     *
     * @param \DateTime|null $reminderEmailSent If defined the date a reminder email was sent for the current billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return self
     */
    public function setReminderEmailSent($reminderEmailSent)
    {
        if (is_null($reminderEmailSent)) {
            throw new \InvalidArgumentException('non-nullable reminderEmailSent cannot be null');
        }
        $this->container['reminderEmailSent'] = $reminderEmailSent;

        return $this;
    }

    /**
     * Gets subscriptionDiscounts
     *
     * @return string[]|null
     */
    public function getSubscriptionDiscounts()
    {
        return $this->container['subscriptionDiscounts'];
    }

    /**
     * Sets subscriptionDiscounts
     *
     * @param string[]|null $subscriptionDiscounts List of subscription discounts handles attached to subscription
     *
     * @return self
     */
    public function setSubscriptionDiscounts($subscriptionDiscounts)
    {
        if (is_null($subscriptionDiscounts)) {
            throw new \InvalidArgumentException('non-nullable subscriptionDiscounts cannot be null');
        }
        $this->container['subscriptionDiscounts'] = $subscriptionDiscounts;

        return $this;
    }

    /**
     * Gets pendingChange
     *
     * @return \Frisbii\Model\SubscriptionChange|null
     */
    public function getPendingChange()
    {
        return $this->container['pendingChange'];
    }

    /**
     * Sets pendingChange
     *
     * @param \Frisbii\Model\SubscriptionChange|null $pendingChange pendingChange
     *
     * @return self
     */
    public function setPendingChange($pendingChange)
    {
        if (is_null($pendingChange)) {
            throw new \InvalidArgumentException('non-nullable pendingChange cannot be null');
        }
        $this->container['pendingChange'] = $pendingChange;

        return $this;
    }

    /**
     * Gets subscriptionChanges
     *
     * @return \Frisbii\Model\SubscriptionChange[]|null
     */
    public function getSubscriptionChanges()
    {
        return $this->container['subscriptionChanges'];
    }

    /**
     * Sets subscriptionChanges
     *
     * @param \Frisbii\Model\SubscriptionChange[]|null $subscriptionChanges List of subscription changes both at most one pending and previously applied
     *
     * @return self
     */
    public function setSubscriptionChanges($subscriptionChanges)
    {
        if (is_null($subscriptionChanges)) {
            throw new \InvalidArgumentException('non-nullable subscriptionChanges cannot be null');
        }
        $this->container['subscriptionChanges'] = $subscriptionChanges;

        return $this;
    }

    /**
     * Gets subscriptionAddOns
     *
     * @return string[]|null
     */
    public function getSubscriptionAddOns()
    {
        return $this->container['subscriptionAddOns'];
    }

    /**
     * Sets subscriptionAddOns
     *
     * @param string[]|null $subscriptionAddOns List of subscription add-on handles attached to subscription
     *
     * @return self
     */
    public function setSubscriptionAddOns($subscriptionAddOns)
    {
        if (is_null($subscriptionAddOns)) {
            throw new \InvalidArgumentException('non-nullable subscriptionAddOns cannot be null');
        }
        $this->container['subscriptionAddOns'] = $subscriptionAddOns;

        return $this;
    }

    /**
     * Gets activePaymentMethods
     *
     * @return string[]|null
     */
    public function getActivePaymentMethods()
    {
        return $this->container['activePaymentMethods'];
    }

    /**
     * Sets activePaymentMethods
     *
     * @param string[]|null $activePaymentMethods A list of active payment method ids. This list will at most contain 1 item.
     *
     * @return self
     */
    public function setActivePaymentMethods($activePaymentMethods)
    {
        if (is_null($activePaymentMethods)) {
            throw new \InvalidArgumentException('non-nullable activePaymentMethods cannot be null');
        }
        $this->container['activePaymentMethods'] = $activePaymentMethods;

        return $this;
    }

    /**
     * Gets meteredBillingProducts
     *
     * @return string[]|null
     */
    public function getMeteredBillingProducts()
    {
        return $this->container['meteredBillingProducts'];
    }

    /**
     * Sets meteredBillingProducts
     *
     * @param string[]|null $meteredBillingProducts List of metered billing products attached to the subscription
     *
     * @return self
     */
    public function setMeteredBillingProducts($meteredBillingProducts)
    {
        if (is_null($meteredBillingProducts)) {
            throw new \InvalidArgumentException('non-nullable meteredBillingProducts cannot be null');
        }
        $this->container['meteredBillingProducts'] = $meteredBillingProducts;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


