<?php
/**
 * CreateCharge
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  Frisbii
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * API
 *
 * REST API to manage Frisbii resources
 *
 * The version of the OpenAPI document: 1
 * Contact: support@frisbii.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.6.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Frisbii\Model;

use \ArrayAccess;
use \Frisbii\ObjectSerializer;

/**
 * CreateCharge Class Doc Comment
 *
 * @category Class
 * @package  Frisbii
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class CreateCharge implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'CreateCharge';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'handle' => 'string',
        'source' => 'string',
        'key' => 'string',
        'amount' => 'int',
        'currency' => 'string',
        'customer' => '\Frisbii\Model\CreateCustomer',
        'metadata' => 'array<string,object>',
        'settle' => 'bool',
        'recurring' => 'bool',
        'parameters' => '\Frisbii\Model\ChargeParameters',
        'ordertext' => 'string',
        'orderLines' => '\Frisbii\Model\CreateOrderLine[]',
        'customerHandle' => 'string',
        'billingAddress' => '\Frisbii\Model\InvoiceBillingAddress',
        'shippingAddress' => '\Frisbii\Model\InvoiceShippingAddress',
        'usePmForSubscription' => 'bool',
        'textOnStatement' => 'string',
        'paymentMethodReference' => 'string',
        'async' => 'bool',
        'acquirerReference' => 'string',
        'accountFundingInformation' => '\Frisbii\Model\AccountFundingInformation',
        'accountFunding' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'handle' => null,
        'source' => null,
        'key' => null,
        'amount' => 'int32',
        'currency' => null,
        'customer' => null,
        'metadata' => null,
        'settle' => null,
        'recurring' => null,
        'parameters' => null,
        'ordertext' => null,
        'orderLines' => null,
        'customerHandle' => null,
        'billingAddress' => null,
        'shippingAddress' => null,
        'usePmForSubscription' => null,
        'textOnStatement' => null,
        'paymentMethodReference' => null,
        'async' => null,
        'acquirerReference' => null,
        'accountFundingInformation' => null,
        'accountFunding' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'handle' => false,
        'source' => false,
        'key' => false,
        'amount' => false,
        'currency' => false,
        'customer' => false,
        'metadata' => false,
        'settle' => false,
        'recurring' => false,
        'parameters' => false,
        'ordertext' => false,
        'orderLines' => false,
        'customerHandle' => false,
        'billingAddress' => false,
        'shippingAddress' => false,
        'usePmForSubscription' => false,
        'textOnStatement' => false,
        'paymentMethodReference' => false,
        'async' => false,
        'acquirerReference' => false,
        'accountFundingInformation' => false,
        'accountFunding' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'handle' => 'handle',
        'source' => 'source',
        'key' => 'key',
        'amount' => 'amount',
        'currency' => 'currency',
        'customer' => 'customer',
        'metadata' => 'metadata',
        'settle' => 'settle',
        'recurring' => 'recurring',
        'parameters' => 'parameters',
        'ordertext' => 'ordertext',
        'orderLines' => 'order_lines',
        'customerHandle' => 'customer_handle',
        'billingAddress' => 'billing_address',
        'shippingAddress' => 'shipping_address',
        'usePmForSubscription' => 'use_pm_for_subscription',
        'textOnStatement' => 'text_on_statement',
        'paymentMethodReference' => 'payment_method_reference',
        'async' => 'async',
        'acquirerReference' => 'acquirer_reference',
        'accountFundingInformation' => 'account_funding_information',
        'accountFunding' => 'account_funding'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'handle' => 'setHandle',
        'source' => 'setSource',
        'key' => 'setKey',
        'amount' => 'setAmount',
        'currency' => 'setCurrency',
        'customer' => 'setCustomer',
        'metadata' => 'setMetadata',
        'settle' => 'setSettle',
        'recurring' => 'setRecurring',
        'parameters' => 'setParameters',
        'ordertext' => 'setOrdertext',
        'orderLines' => 'setOrderLines',
        'customerHandle' => 'setCustomerHandle',
        'billingAddress' => 'setBillingAddress',
        'shippingAddress' => 'setShippingAddress',
        'usePmForSubscription' => 'setUsePmForSubscription',
        'textOnStatement' => 'setTextOnStatement',
        'paymentMethodReference' => 'setPaymentMethodReference',
        'async' => 'setAsync',
        'acquirerReference' => 'setAcquirerReference',
        'accountFundingInformation' => 'setAccountFundingInformation',
        'accountFunding' => 'setAccountFunding'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'handle' => 'getHandle',
        'source' => 'getSource',
        'key' => 'getKey',
        'amount' => 'getAmount',
        'currency' => 'getCurrency',
        'customer' => 'getCustomer',
        'metadata' => 'getMetadata',
        'settle' => 'getSettle',
        'recurring' => 'getRecurring',
        'parameters' => 'getParameters',
        'ordertext' => 'getOrdertext',
        'orderLines' => 'getOrderLines',
        'customerHandle' => 'getCustomerHandle',
        'billingAddress' => 'getBillingAddress',
        'shippingAddress' => 'getShippingAddress',
        'usePmForSubscription' => 'getUsePmForSubscription',
        'textOnStatement' => 'getTextOnStatement',
        'paymentMethodReference' => 'getPaymentMethodReference',
        'async' => 'getAsync',
        'acquirerReference' => 'getAcquirerReference',
        'accountFundingInformation' => 'getAccountFundingInformation',
        'accountFunding' => 'getAccountFunding'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('handle', $data ?? [], null);
        $this->setIfExists('source', $data ?? [], null);
        $this->setIfExists('key', $data ?? [], null);
        $this->setIfExists('amount', $data ?? [], null);
        $this->setIfExists('currency', $data ?? [], null);
        $this->setIfExists('customer', $data ?? [], null);
        $this->setIfExists('metadata', $data ?? [], null);
        $this->setIfExists('settle', $data ?? [], null);
        $this->setIfExists('recurring', $data ?? [], null);
        $this->setIfExists('parameters', $data ?? [], null);
        $this->setIfExists('ordertext', $data ?? [], null);
        $this->setIfExists('orderLines', $data ?? [], null);
        $this->setIfExists('customerHandle', $data ?? [], null);
        $this->setIfExists('billingAddress', $data ?? [], null);
        $this->setIfExists('shippingAddress', $data ?? [], null);
        $this->setIfExists('usePmForSubscription', $data ?? [], null);
        $this->setIfExists('textOnStatement', $data ?? [], null);
        $this->setIfExists('paymentMethodReference', $data ?? [], null);
        $this->setIfExists('async', $data ?? [], null);
        $this->setIfExists('acquirerReference', $data ?? [], null);
        $this->setIfExists('accountFundingInformation', $data ?? [], null);
        $this->setIfExists('accountFunding', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['handle'] === null) {
            $invalidProperties[] = "'handle' can't be null";
        }
        if ((mb_strlen($this->container['handle']) < 1)) {
            $invalidProperties[] = "invalid value for 'handle', the character length must be bigger than or equal to 1.";
        }

        if ($this->container['source'] === null) {
            $invalidProperties[] = "'source' can't be null";
        }
        if ((mb_strlen($this->container['source']) < 1)) {
            $invalidProperties[] = "invalid value for 'source', the character length must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['amount']) && ($this->container['amount'] < 1)) {
            $invalidProperties[] = "invalid value for 'amount', must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['orderLines']) && (count($this->container['orderLines']) > 1000)) {
            $invalidProperties[] = "invalid value for 'orderLines', number of items must be less than or equal to 1000.";
        }

        if (!is_null($this->container['orderLines']) && (count($this->container['orderLines']) < 0)) {
            $invalidProperties[] = "invalid value for 'orderLines', number of items must be greater than or equal to 0.";
        }

        if (!is_null($this->container['textOnStatement']) && !preg_match("/^[\\x20-\\x7F]*$/", $this->container['textOnStatement'])) {
            $invalidProperties[] = "invalid value for 'textOnStatement', must be conform to the pattern /^[\\x20-\\x7F]*$/.";
        }

        if (!is_null($this->container['acquirerReference']) && !preg_match("/^[\\x20-\\x7F]*$/", $this->container['acquirerReference'])) {
            $invalidProperties[] = "invalid value for 'acquirerReference', must be conform to the pattern /^[\\x20-\\x7F]*$/.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets handle
     *
     * @return string
     */
    public function getHandle()
    {
        return $this->container['handle'];
    }

    /**
     * Sets handle
     *
     * @param string $handle Per account unique reference to charge/invoice. E.g. order id from own system. Multiple payments can be attempted for the same handle but only one authorized or settled charge can exist per handle. Max length 255 with allowable characters [a-zA-Z0-9_.-@]. It is recommended to use a maximum of 20 characters as this will allow for the use of handle as reference on bank statements without truncation.
     *
     * @return self
     */
    public function setHandle($handle)
    {
        if (is_null($handle)) {
            throw new \InvalidArgumentException('non-nullable handle cannot be null');
        }

        if ((mb_strlen($handle) < 1)) {
            throw new \InvalidArgumentException('invalid length for $handle when calling CreateCharge., must be bigger than or equal to 1.');
        }

        $this->container['handle'] = $handle;

        return $this;
    }

    /**
     * Gets source
     *
     * @return string
     */
    public function getSource()
    {
        return $this->container['source'];
    }

    /**
     * Sets source
     *
     * @param string $source The source for the payment. Either an existing payment method for the customer or a card token `ct_...`. The existing payment method can either be referenced directly with id, e.g. `ca_...`, or the keyword `auto` can be given to indicate that the newest active customer payment method should be used.
     *
     * @return self
     */
    public function setSource($source)
    {
        if (is_null($source)) {
            throw new \InvalidArgumentException('non-nullable source cannot be null');
        }

        if ((mb_strlen($source) < 1)) {
            throw new \InvalidArgumentException('invalid length for $source when calling CreateCharge., must be bigger than or equal to 1.');
        }

        $this->container['source'] = $source;

        return $this;
    }

    /**
     * Gets key
     *
     * @return string|null
     */
    public function getKey()
    {
        return $this->container['key'];
    }

    /**
     * Sets key
     *
     * @param string|null $key Optional idempotency key. Only one authorization or settle can be performed for the same handle. If two create attempts are attempted and the first succeeds the second will fail because charge is already settled or authorized. An idempotency key identifies uniquely the request and multiple requests with the same key and handle will yield the same result. In case of networking errors the same request with same key can safely be retried.
     *
     * @return self
     */
    public function setKey($key)
    {
        if (is_null($key)) {
            throw new \InvalidArgumentException('non-nullable key cannot be null');
        }
        $this->container['key'] = $key;

        return $this;
    }

    /**
     * Gets amount
     *
     * @return int|null
     */
    public function getAmount()
    {
        return $this->container['amount'];
    }

    /**
     * Sets amount
     *
     * @param int|null $amount Amount in the smallest unit. Either `amount` or `order_lines` must be provided if charge/invoice does not already exists.
     *
     * @return self
     */
    public function setAmount($amount)
    {
        if (is_null($amount)) {
            throw new \InvalidArgumentException('non-nullable amount cannot be null');
        }

        if (($amount < 1)) {
            throw new \InvalidArgumentException('invalid value for $amount when calling CreateCharge., must be bigger than or equal to 1.');
        }

        $this->container['amount'] = $amount;

        return $this;
    }

    /**
     * Gets currency
     *
     * @return string|null
     */
    public function getCurrency()
    {
        return $this->container['currency'];
    }

    /**
     * Sets currency
     *
     * @param string|null $currency Optional currency in [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) three letter alpha code. If not provided the account default currency will be used. The currency of an existing charge or invoice cannot be changed.
     *
     * @return self
     */
    public function setCurrency($currency)
    {
        if (is_null($currency)) {
            throw new \InvalidArgumentException('non-nullable currency cannot be null');
        }
        $this->container['currency'] = $currency;

        return $this;
    }

    /**
     * Gets customer
     *
     * @return \Frisbii\Model\CreateCustomer|null
     */
    public function getCustomer()
    {
        return $this->container['customer'];
    }

    /**
     * Sets customer
     *
     * @param \Frisbii\Model\CreateCustomer|null $customer customer
     *
     * @return self
     */
    public function setCustomer($customer)
    {
        if (is_null($customer)) {
            throw new \InvalidArgumentException('non-nullable customer cannot be null');
        }
        $this->container['customer'] = $customer;

        return $this;
    }

    /**
     * Gets metadata
     *
     * @return array<string,object>|null
     */
    public function getMetadata()
    {
        return $this->container['metadata'];
    }

    /**
     * Sets metadata
     *
     * @param array<string,object>|null $metadata Custom metadata.
     *
     * @return self
     */
    public function setMetadata($metadata)
    {
        if (is_null($metadata)) {
            throw new \InvalidArgumentException('non-nullable metadata cannot be null');
        }
        $this->container['metadata'] = $metadata;

        return $this;
    }

    /**
     * Gets settle
     *
     * @return bool|null
     */
    public function getSettle()
    {
        return $this->container['settle'];
    }

    /**
     * Sets settle
     *
     * @param bool|null $settle Whether or not to immediately settle the charge. If not settled immediately the charge will be authorized and can later be settled. Normally this have to be done within 7 days. The default is not to settle the charge immediately. Note that not all payment methods support immediate settle.
     *
     * @return self
     */
    public function setSettle($settle)
    {
        if (is_null($settle)) {
            throw new \InvalidArgumentException('non-nullable settle cannot be null');
        }
        $this->container['settle'] = $settle;

        return $this;
    }

    /**
     * Gets recurring
     *
     * @return bool|null
     */
    public function getRecurring()
    {
        return $this->container['recurring'];
    }

    /**
     * Sets recurring
     *
     * @param bool|null $recurring If set and the source is a token for a payment method that supports recurring charging (e.g. credit card), a recurring payment method is stored for the customer and a reference returned.
     *
     * @return self
     */
    public function setRecurring($recurring)
    {
        if (is_null($recurring)) {
            throw new \InvalidArgumentException('non-nullable recurring cannot be null');
        }
        $this->container['recurring'] = $recurring;

        return $this;
    }

    /**
     * Gets parameters
     *
     * @return \Frisbii\Model\ChargeParameters|null
     */
    public function getParameters()
    {
        return $this->container['parameters'];
    }

    /**
     * Sets parameters
     *
     * @param \Frisbii\Model\ChargeParameters|null $parameters parameters
     *
     * @return self
     */
    public function setParameters($parameters)
    {
        if (is_null($parameters)) {
            throw new \InvalidArgumentException('non-nullable parameters cannot be null');
        }
        $this->container['parameters'] = $parameters;

        return $this;
    }

    /**
     * Gets ordertext
     *
     * @return string|null
     */
    public function getOrdertext()
    {
        return $this->container['ordertext'];
    }

    /**
     * Sets ordertext
     *
     * @param string|null $ordertext Optional order text. Used in conjunction with `amount`. Ignored if `order_lines` is provided.
     *
     * @return self
     */
    public function setOrdertext($ordertext)
    {
        if (is_null($ordertext)) {
            throw new \InvalidArgumentException('non-nullable ordertext cannot be null');
        }
        $this->container['ordertext'] = $ordertext;

        return $this;
    }

    /**
     * Gets orderLines
     *
     * @return \Frisbii\Model\CreateOrderLine[]|null
     */
    public function getOrderLines()
    {
        return $this->container['orderLines'];
    }

    /**
     * Sets orderLines
     *
     * @param \Frisbii\Model\CreateOrderLine[]|null $orderLines Order lines for the charge. The order lines controls the amount. Only required if charge/invoice does not already exist. If given for existing charge the order lines and amount are adjusted. A maximum of 100 order lines is allowed.
     *
     * @return self
     */
    public function setOrderLines($orderLines)
    {
        if (is_null($orderLines)) {
            throw new \InvalidArgumentException('non-nullable orderLines cannot be null');
        }

        if ((count($orderLines) > 1000)) {
            throw new \InvalidArgumentException('invalid value for $orderLines when calling CreateCharge., number of items must be less than or equal to 1000.');
        }
        if ((count($orderLines) < 0)) {
            throw new \InvalidArgumentException('invalid length for $orderLines when calling CreateCharge., number of items must be greater than or equal to 0.');
        }
        $this->container['orderLines'] = $orderLines;

        return $this;
    }

    /**
     * Gets customerHandle
     *
     * @return string|null
     */
    public function getCustomerHandle()
    {
        return $this->container['customerHandle'];
    }

    /**
     * Sets customerHandle
     *
     * @param string|null $customerHandle Customer reference. If charge does not already exist either this reference must be provided, a create customer object must be provided or the source must be a payment method reference (e.g. `ca_..`) identifying customer. Notice that customer cannot be changed for existing charge/invoice so if handle is provided it must match the customer handle for existing customer.
     *
     * @return self
     */
    public function setCustomerHandle($customerHandle)
    {
        if (is_null($customerHandle)) {
            throw new \InvalidArgumentException('non-nullable customerHandle cannot be null');
        }
        $this->container['customerHandle'] = $customerHandle;

        return $this;
    }

    /**
     * Gets billingAddress
     *
     * @return \Frisbii\Model\InvoiceBillingAddress|null
     */
    public function getBillingAddress()
    {
        return $this->container['billingAddress'];
    }

    /**
     * Sets billingAddress
     *
     * @param \Frisbii\Model\InvoiceBillingAddress|null $billingAddress billingAddress
     *
     * @return self
     */
    public function setBillingAddress($billingAddress)
    {
        if (is_null($billingAddress)) {
            throw new \InvalidArgumentException('non-nullable billingAddress cannot be null');
        }
        $this->container['billingAddress'] = $billingAddress;

        return $this;
    }

    /**
     * Gets shippingAddress
     *
     * @return \Frisbii\Model\InvoiceShippingAddress|null
     */
    public function getShippingAddress()
    {
        return $this->container['shippingAddress'];
    }

    /**
     * Sets shippingAddress
     *
     * @param \Frisbii\Model\InvoiceShippingAddress|null $shippingAddress shippingAddress
     *
     * @return self
     */
    public function setShippingAddress($shippingAddress)
    {
        if (is_null($shippingAddress)) {
            throw new \InvalidArgumentException('non-nullable shippingAddress cannot be null');
        }
        $this->container['shippingAddress'] = $shippingAddress;

        return $this;
    }

    /**
     * Gets usePmForSubscription
     *
     * @return bool|null
     */
    public function getUsePmForSubscription()
    {
        return $this->container['usePmForSubscription'];
    }

    /**
     * Sets usePmForSubscription
     *
     * @param bool|null $usePmForSubscription When used with a subscription invoice the subscription payment method will be updated. If the subscription is pending the subscription will be activated with the payment method. The recurring argument is set to true.
     *
     * @return self
     */
    public function setUsePmForSubscription($usePmForSubscription)
    {
        if (is_null($usePmForSubscription)) {
            throw new \InvalidArgumentException('non-nullable usePmForSubscription cannot be null');
        }
        $this->container['usePmForSubscription'] = $usePmForSubscription;

        return $this;
    }

    /**
     * Gets textOnStatement
     *
     * @return string|null
     */
    public function getTextOnStatement()
    {
        return $this->container['textOnStatement'];
    }

    /**
     * Sets textOnStatement
     *
     * @param string|null $textOnStatement Optional argument to define the text on bank statement. Notice the following about this argument: 1. It only works for some acquirers. 2. Acquirers may have rigid rules on the content of the text on statement. Not complying to these rules will result in declined payments. 3) It is already possible to define custom text on statement using templating in the Frisbii Administration. Contact support for help. We highly recommend to only supply this argument if absolutely necessary, and the templated default text on statement is not sufficient. Maximum length is 128, but most acquirers require a maximum length of 22 characters. Truncating will be applied if too long for specific acquirer. Characters must match regex `[\\x20-\\x7F]`
     *
     * @return self
     */
    public function setTextOnStatement($textOnStatement)
    {
        if (is_null($textOnStatement)) {
            throw new \InvalidArgumentException('non-nullable textOnStatement cannot be null');
        }

        if ((!preg_match("/^[\\x20-\\x7F]*$/", ObjectSerializer::toString($textOnStatement)))) {
            throw new \InvalidArgumentException("invalid value for \$textOnStatement when calling CreateCharge., must conform to the pattern /^[\\x20-\\x7F]*$/.");
        }

        $this->container['textOnStatement'] = $textOnStatement;

        return $this;
    }

    /**
     * Gets paymentMethodReference
     *
     * @return string|null
     */
    public function getPaymentMethodReference()
    {
        return $this->container['paymentMethodReference'];
    }

    /**
     * Sets paymentMethodReference
     *
     * @param string|null $paymentMethodReference Optional reference given to the created payment method in case recurring argument is used to save payment method. Max length 64 with allowable characters [a-zA-Z0-9_.-@].
     *
     * @return self
     */
    public function setPaymentMethodReference($paymentMethodReference)
    {
        if (is_null($paymentMethodReference)) {
            throw new \InvalidArgumentException('non-nullable paymentMethodReference cannot be null');
        }
        $this->container['paymentMethodReference'] = $paymentMethodReference;

        return $this;
    }

    /**
     * Gets async
     *
     * @return bool|null
     */
    public function getAsync()
    {
        return $this->container['async'];
    }

    /**
     * Sets async
     *
     * @param bool|null $async For payment methods that supports both synchronous and asynchronous handling this parameter can be used force a specific handling. Asynchronous handling means that a pending state will be returned. The subsequent state change can be registered by using webhooks. The default depends on the payment method.
     *
     * @return self
     */
    public function setAsync($async)
    {
        if (is_null($async)) {
            throw new \InvalidArgumentException('non-nullable async cannot be null');
        }
        $this->container['async'] = $async;

        return $this;
    }

    /**
     * Gets acquirerReference
     *
     * @return string|null
     */
    public function getAcquirerReference()
    {
        return $this->container['acquirerReference'];
    }

    /**
     * Sets acquirerReference
     *
     * @param string|null $acquirerReference Optional reference for the transaction at the acquirer. Notice the following about this argument: 1. It only works for some acquirers. 2. Acquirers may have rigid rules on the content of the acquirer reference.  Not complying to these rules can result in declined payments. 3. It is already possible to define custom acquirer reference using templating in the Frisbii Administration.  Contact support for help. We highly recommend to only supply this argument if absolutely necessary,  and the templated default acquirer reference is not sufficient. Maximum length is 128,  but most acquirers require a maximum length of 22 characters.  Truncating will be applied if too long for specific acquirer.  Characters must match regex `[\\x20-\\x7F]`
     *
     * @return self
     */
    public function setAcquirerReference($acquirerReference)
    {
        if (is_null($acquirerReference)) {
            throw new \InvalidArgumentException('non-nullable acquirerReference cannot be null');
        }

        if ((!preg_match("/^[\\x20-\\x7F]*$/", ObjectSerializer::toString($acquirerReference)))) {
            throw new \InvalidArgumentException("invalid value for \$acquirerReference when calling CreateCharge., must conform to the pattern /^[\\x20-\\x7F]*$/.");
        }

        $this->container['acquirerReference'] = $acquirerReference;

        return $this;
    }

    /**
     * Gets accountFundingInformation
     *
     * @return \Frisbii\Model\AccountFundingInformation|null
     */
    public function getAccountFundingInformation()
    {
        return $this->container['accountFundingInformation'];
    }

    /**
     * Sets accountFundingInformation
     *
     * @param \Frisbii\Model\AccountFundingInformation|null $accountFundingInformation accountFundingInformation
     *
     * @return self
     */
    public function setAccountFundingInformation($accountFundingInformation)
    {
        if (is_null($accountFundingInformation)) {
            throw new \InvalidArgumentException('non-nullable accountFundingInformation cannot be null');
        }
        $this->container['accountFundingInformation'] = $accountFundingInformation;

        return $this;
    }

    /**
     * Gets accountFunding
     *
     * @return bool|null
     */
    public function getAccountFunding()
    {
        return $this->container['accountFunding'];
    }

    /**
     * Sets accountFunding
     *
     * @param bool|null $accountFunding Indicates that Account Funding Transaction (AFT) is requested. It only can be used for instant settle (i.e. 'settle' = true)
     *
     * @return self
     */
    public function setAccountFunding($accountFunding)
    {
        if (is_null($accountFunding)) {
            throw new \InvalidArgumentException('non-nullable accountFunding cannot be null');
        }
        $this->container['accountFunding'] = $accountFunding;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


