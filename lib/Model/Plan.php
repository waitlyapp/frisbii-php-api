<?php
/**
 * Plan
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  Frisbii
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * API
 *
 * REST API to manage Frisbii resources
 *
 * The version of the OpenAPI document: 1
 * Contact: support@frisbii.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.6.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Frisbii\Model;

use \ArrayAccess;
use \Frisbii\ObjectSerializer;

/**
 * Plan Class Doc Comment
 *
 * @category Class
 * @description Subscription plan object if change resulted in a new plan
 * @package  Frisbii
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class Plan implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Plan';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'name' => 'string',
        'amount' => 'int',
        'handle' => 'string',
        'version' => 'int',
        'state' => 'string',
        'currency' => 'string',
        'created' => '\DateTime',
        'scheduleType' => 'string',
        'description' => 'string',
        'vat' => 'float',
        'quantity' => 'int',
        'prepaid' => 'bool',
        'deleted' => '\DateTime',
        'dunningPlan' => 'string',
        'taxPolicy' => 'string',
        'renewalReminderEmailDays' => 'int',
        'trialReminderEmailDays' => 'int',
        'partialPeriodHandling' => 'string',
        'includeZeroAmount' => 'bool',
        'setupFee' => 'int',
        'setupFeeText' => 'string',
        'setupFeeHandling' => 'string',
        'partialProrationDays' => 'bool',
        'fixedTrialDays' => 'bool',
        'minimumProratedAmount' => 'int',
        'accountFunding' => 'bool',
        'amountInclVat' => 'bool',
        'fixedCount' => 'int',
        'fixedLifeTimeUnit' => 'string',
        'fixedLifeTimeLength' => 'int',
        'trialIntervalUnit' => 'string',
        'trialIntervalLength' => 'int',
        'intervalLength' => 'int',
        'scheduleFixedDay' => 'int',
        'scheduleFixedHour' => 'int',
        'baseMonth' => 'int',
        'noticePeriods' => 'int',
        'noticePeriodsAfterCurrent' => 'bool',
        'fixationPeriods' => 'int',
        'fixationPeriodsFull' => 'bool',
        'entitlements' => 'string[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'name' => null,
        'amount' => 'int32',
        'handle' => null,
        'version' => 'int32',
        'state' => null,
        'currency' => null,
        'created' => 'date-time',
        'scheduleType' => null,
        'description' => null,
        'vat' => 'float',
        'quantity' => 'int32',
        'prepaid' => null,
        'deleted' => 'date-time',
        'dunningPlan' => null,
        'taxPolicy' => null,
        'renewalReminderEmailDays' => 'int32',
        'trialReminderEmailDays' => 'int32',
        'partialPeriodHandling' => null,
        'includeZeroAmount' => null,
        'setupFee' => 'int32',
        'setupFeeText' => null,
        'setupFeeHandling' => null,
        'partialProrationDays' => null,
        'fixedTrialDays' => null,
        'minimumProratedAmount' => 'int32',
        'accountFunding' => null,
        'amountInclVat' => null,
        'fixedCount' => 'int32',
        'fixedLifeTimeUnit' => null,
        'fixedLifeTimeLength' => 'int32',
        'trialIntervalUnit' => null,
        'trialIntervalLength' => 'int32',
        'intervalLength' => 'int32',
        'scheduleFixedDay' => 'int32',
        'scheduleFixedHour' => 'int32',
        'baseMonth' => 'int32',
        'noticePeriods' => 'int32',
        'noticePeriodsAfterCurrent' => null,
        'fixationPeriods' => 'int32',
        'fixationPeriodsFull' => null,
        'entitlements' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'name' => false,
        'amount' => false,
        'handle' => false,
        'version' => false,
        'state' => false,
        'currency' => false,
        'created' => false,
        'scheduleType' => false,
        'description' => false,
        'vat' => false,
        'quantity' => false,
        'prepaid' => false,
        'deleted' => false,
        'dunningPlan' => false,
        'taxPolicy' => false,
        'renewalReminderEmailDays' => false,
        'trialReminderEmailDays' => false,
        'partialPeriodHandling' => false,
        'includeZeroAmount' => false,
        'setupFee' => false,
        'setupFeeText' => false,
        'setupFeeHandling' => false,
        'partialProrationDays' => false,
        'fixedTrialDays' => false,
        'minimumProratedAmount' => false,
        'accountFunding' => false,
        'amountInclVat' => false,
        'fixedCount' => false,
        'fixedLifeTimeUnit' => false,
        'fixedLifeTimeLength' => false,
        'trialIntervalUnit' => false,
        'trialIntervalLength' => false,
        'intervalLength' => false,
        'scheduleFixedDay' => false,
        'scheduleFixedHour' => false,
        'baseMonth' => false,
        'noticePeriods' => false,
        'noticePeriodsAfterCurrent' => false,
        'fixationPeriods' => false,
        'fixationPeriodsFull' => false,
        'entitlements' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'name' => 'name',
        'amount' => 'amount',
        'handle' => 'handle',
        'version' => 'version',
        'state' => 'state',
        'currency' => 'currency',
        'created' => 'created',
        'scheduleType' => 'schedule_type',
        'description' => 'description',
        'vat' => 'vat',
        'quantity' => 'quantity',
        'prepaid' => 'prepaid',
        'deleted' => 'deleted',
        'dunningPlan' => 'dunning_plan',
        'taxPolicy' => 'tax_policy',
        'renewalReminderEmailDays' => 'renewal_reminder_email_days',
        'trialReminderEmailDays' => 'trial_reminder_email_days',
        'partialPeriodHandling' => 'partial_period_handling',
        'includeZeroAmount' => 'include_zero_amount',
        'setupFee' => 'setup_fee',
        'setupFeeText' => 'setup_fee_text',
        'setupFeeHandling' => 'setup_fee_handling',
        'partialProrationDays' => 'partial_proration_days',
        'fixedTrialDays' => 'fixed_trial_days',
        'minimumProratedAmount' => 'minimum_prorated_amount',
        'accountFunding' => 'account_funding',
        'amountInclVat' => 'amount_incl_vat',
        'fixedCount' => 'fixed_count',
        'fixedLifeTimeUnit' => 'fixed_life_time_unit',
        'fixedLifeTimeLength' => 'fixed_life_time_length',
        'trialIntervalUnit' => 'trial_interval_unit',
        'trialIntervalLength' => 'trial_interval_length',
        'intervalLength' => 'interval_length',
        'scheduleFixedDay' => 'schedule_fixed_day',
        'scheduleFixedHour' => 'schedule_fixed_hour',
        'baseMonth' => 'base_month',
        'noticePeriods' => 'notice_periods',
        'noticePeriodsAfterCurrent' => 'notice_periods_after_current',
        'fixationPeriods' => 'fixation_periods',
        'fixationPeriodsFull' => 'fixation_periods_full',
        'entitlements' => 'entitlements'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'name' => 'setName',
        'amount' => 'setAmount',
        'handle' => 'setHandle',
        'version' => 'setVersion',
        'state' => 'setState',
        'currency' => 'setCurrency',
        'created' => 'setCreated',
        'scheduleType' => 'setScheduleType',
        'description' => 'setDescription',
        'vat' => 'setVat',
        'quantity' => 'setQuantity',
        'prepaid' => 'setPrepaid',
        'deleted' => 'setDeleted',
        'dunningPlan' => 'setDunningPlan',
        'taxPolicy' => 'setTaxPolicy',
        'renewalReminderEmailDays' => 'setRenewalReminderEmailDays',
        'trialReminderEmailDays' => 'setTrialReminderEmailDays',
        'partialPeriodHandling' => 'setPartialPeriodHandling',
        'includeZeroAmount' => 'setIncludeZeroAmount',
        'setupFee' => 'setSetupFee',
        'setupFeeText' => 'setSetupFeeText',
        'setupFeeHandling' => 'setSetupFeeHandling',
        'partialProrationDays' => 'setPartialProrationDays',
        'fixedTrialDays' => 'setFixedTrialDays',
        'minimumProratedAmount' => 'setMinimumProratedAmount',
        'accountFunding' => 'setAccountFunding',
        'amountInclVat' => 'setAmountInclVat',
        'fixedCount' => 'setFixedCount',
        'fixedLifeTimeUnit' => 'setFixedLifeTimeUnit',
        'fixedLifeTimeLength' => 'setFixedLifeTimeLength',
        'trialIntervalUnit' => 'setTrialIntervalUnit',
        'trialIntervalLength' => 'setTrialIntervalLength',
        'intervalLength' => 'setIntervalLength',
        'scheduleFixedDay' => 'setScheduleFixedDay',
        'scheduleFixedHour' => 'setScheduleFixedHour',
        'baseMonth' => 'setBaseMonth',
        'noticePeriods' => 'setNoticePeriods',
        'noticePeriodsAfterCurrent' => 'setNoticePeriodsAfterCurrent',
        'fixationPeriods' => 'setFixationPeriods',
        'fixationPeriodsFull' => 'setFixationPeriodsFull',
        'entitlements' => 'setEntitlements'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'name' => 'getName',
        'amount' => 'getAmount',
        'handle' => 'getHandle',
        'version' => 'getVersion',
        'state' => 'getState',
        'currency' => 'getCurrency',
        'created' => 'getCreated',
        'scheduleType' => 'getScheduleType',
        'description' => 'getDescription',
        'vat' => 'getVat',
        'quantity' => 'getQuantity',
        'prepaid' => 'getPrepaid',
        'deleted' => 'getDeleted',
        'dunningPlan' => 'getDunningPlan',
        'taxPolicy' => 'getTaxPolicy',
        'renewalReminderEmailDays' => 'getRenewalReminderEmailDays',
        'trialReminderEmailDays' => 'getTrialReminderEmailDays',
        'partialPeriodHandling' => 'getPartialPeriodHandling',
        'includeZeroAmount' => 'getIncludeZeroAmount',
        'setupFee' => 'getSetupFee',
        'setupFeeText' => 'getSetupFeeText',
        'setupFeeHandling' => 'getSetupFeeHandling',
        'partialProrationDays' => 'getPartialProrationDays',
        'fixedTrialDays' => 'getFixedTrialDays',
        'minimumProratedAmount' => 'getMinimumProratedAmount',
        'accountFunding' => 'getAccountFunding',
        'amountInclVat' => 'getAmountInclVat',
        'fixedCount' => 'getFixedCount',
        'fixedLifeTimeUnit' => 'getFixedLifeTimeUnit',
        'fixedLifeTimeLength' => 'getFixedLifeTimeLength',
        'trialIntervalUnit' => 'getTrialIntervalUnit',
        'trialIntervalLength' => 'getTrialIntervalLength',
        'intervalLength' => 'getIntervalLength',
        'scheduleFixedDay' => 'getScheduleFixedDay',
        'scheduleFixedHour' => 'getScheduleFixedHour',
        'baseMonth' => 'getBaseMonth',
        'noticePeriods' => 'getNoticePeriods',
        'noticePeriodsAfterCurrent' => 'getNoticePeriodsAfterCurrent',
        'fixationPeriods' => 'getFixationPeriods',
        'fixationPeriodsFull' => 'getFixationPeriodsFull',
        'entitlements' => 'getEntitlements'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const STATE_ACTIVE = 'active';
    public const STATE_SUPERSEDED = 'superseded';
    public const STATE_DELETED = 'deleted';
    public const STATE_UNKNOWN_DEFAULT_OPEN_API = 'unknown_default_open_api';
    public const SCHEDULE_TYPE_MANUAL = 'manual';
    public const SCHEDULE_TYPE_DAILY = 'daily';
    public const SCHEDULE_TYPE_WEEKLY_FIXEDDAY = 'weekly_fixedday';
    public const SCHEDULE_TYPE_MONTH_STARTDATE = 'month_startdate';
    public const SCHEDULE_TYPE_MONTH_FIXEDDAY = 'month_fixedday';
    public const SCHEDULE_TYPE_MONTH_LASTDAY = 'month_lastday';
    public const SCHEDULE_TYPE_UNKNOWN_DEFAULT_OPEN_API = 'unknown_default_open_api';
    public const PARTIAL_PERIOD_HANDLING_BILL_FULL = 'bill_full';
    public const PARTIAL_PERIOD_HANDLING_BILL_PRORATED = 'bill_prorated';
    public const PARTIAL_PERIOD_HANDLING_BILL_ZERO_AMOUNT = 'bill_zero_amount';
    public const PARTIAL_PERIOD_HANDLING_NO_BILL = 'no_bill';
    public const PARTIAL_PERIOD_HANDLING_UNKNOWN_DEFAULT_OPEN_API = 'unknown_default_open_api';
    public const FIXED_LIFE_TIME_UNIT_MONTHS = 'months';
    public const FIXED_LIFE_TIME_UNIT_DAYS = 'days';
    public const FIXED_LIFE_TIME_UNIT_UNKNOWN_DEFAULT_OPEN_API = 'unknown_default_open_api';
    public const TRIAL_INTERVAL_UNIT_MONTHS = 'months';
    public const TRIAL_INTERVAL_UNIT_DAYS = 'days';
    public const TRIAL_INTERVAL_UNIT_UNKNOWN_DEFAULT_OPEN_API = 'unknown_default_open_api';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStateAllowableValues()
    {
        return [
            self::STATE_ACTIVE,
            self::STATE_SUPERSEDED,
            self::STATE_DELETED,
            self::STATE_UNKNOWN_DEFAULT_OPEN_API,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getScheduleTypeAllowableValues()
    {
        return [
            self::SCHEDULE_TYPE_MANUAL,
            self::SCHEDULE_TYPE_DAILY,
            self::SCHEDULE_TYPE_WEEKLY_FIXEDDAY,
            self::SCHEDULE_TYPE_MONTH_STARTDATE,
            self::SCHEDULE_TYPE_MONTH_FIXEDDAY,
            self::SCHEDULE_TYPE_MONTH_LASTDAY,
            self::SCHEDULE_TYPE_UNKNOWN_DEFAULT_OPEN_API,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPartialPeriodHandlingAllowableValues()
    {
        return [
            self::PARTIAL_PERIOD_HANDLING_BILL_FULL,
            self::PARTIAL_PERIOD_HANDLING_BILL_PRORATED,
            self::PARTIAL_PERIOD_HANDLING_BILL_ZERO_AMOUNT,
            self::PARTIAL_PERIOD_HANDLING_NO_BILL,
            self::PARTIAL_PERIOD_HANDLING_UNKNOWN_DEFAULT_OPEN_API,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getFixedLifeTimeUnitAllowableValues()
    {
        return [
            self::FIXED_LIFE_TIME_UNIT_MONTHS,
            self::FIXED_LIFE_TIME_UNIT_DAYS,
            self::FIXED_LIFE_TIME_UNIT_UNKNOWN_DEFAULT_OPEN_API,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTrialIntervalUnitAllowableValues()
    {
        return [
            self::TRIAL_INTERVAL_UNIT_MONTHS,
            self::TRIAL_INTERVAL_UNIT_DAYS,
            self::TRIAL_INTERVAL_UNIT_UNKNOWN_DEFAULT_OPEN_API,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('name', $data ?? [], null);
        $this->setIfExists('amount', $data ?? [], null);
        $this->setIfExists('handle', $data ?? [], null);
        $this->setIfExists('version', $data ?? [], null);
        $this->setIfExists('state', $data ?? [], null);
        $this->setIfExists('currency', $data ?? [], null);
        $this->setIfExists('created', $data ?? [], null);
        $this->setIfExists('scheduleType', $data ?? [], null);
        $this->setIfExists('description', $data ?? [], null);
        $this->setIfExists('vat', $data ?? [], null);
        $this->setIfExists('quantity', $data ?? [], null);
        $this->setIfExists('prepaid', $data ?? [], null);
        $this->setIfExists('deleted', $data ?? [], null);
        $this->setIfExists('dunningPlan', $data ?? [], null);
        $this->setIfExists('taxPolicy', $data ?? [], null);
        $this->setIfExists('renewalReminderEmailDays', $data ?? [], null);
        $this->setIfExists('trialReminderEmailDays', $data ?? [], null);
        $this->setIfExists('partialPeriodHandling', $data ?? [], null);
        $this->setIfExists('includeZeroAmount', $data ?? [], null);
        $this->setIfExists('setupFee', $data ?? [], null);
        $this->setIfExists('setupFeeText', $data ?? [], null);
        $this->setIfExists('setupFeeHandling', $data ?? [], null);
        $this->setIfExists('partialProrationDays', $data ?? [], null);
        $this->setIfExists('fixedTrialDays', $data ?? [], null);
        $this->setIfExists('minimumProratedAmount', $data ?? [], null);
        $this->setIfExists('accountFunding', $data ?? [], null);
        $this->setIfExists('amountInclVat', $data ?? [], null);
        $this->setIfExists('fixedCount', $data ?? [], null);
        $this->setIfExists('fixedLifeTimeUnit', $data ?? [], null);
        $this->setIfExists('fixedLifeTimeLength', $data ?? [], null);
        $this->setIfExists('trialIntervalUnit', $data ?? [], null);
        $this->setIfExists('trialIntervalLength', $data ?? [], null);
        $this->setIfExists('intervalLength', $data ?? [], null);
        $this->setIfExists('scheduleFixedDay', $data ?? [], null);
        $this->setIfExists('scheduleFixedHour', $data ?? [], null);
        $this->setIfExists('baseMonth', $data ?? [], null);
        $this->setIfExists('noticePeriods', $data ?? [], null);
        $this->setIfExists('noticePeriodsAfterCurrent', $data ?? [], null);
        $this->setIfExists('fixationPeriods', $data ?? [], null);
        $this->setIfExists('fixationPeriodsFull', $data ?? [], null);
        $this->setIfExists('entitlements', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['name'] === null) {
            $invalidProperties[] = "'name' can't be null";
        }
        if ((mb_strlen($this->container['name']) < 1)) {
            $invalidProperties[] = "invalid value for 'name', the character length must be bigger than or equal to 1.";
        }

        if ($this->container['amount'] === null) {
            $invalidProperties[] = "'amount' can't be null";
        }
        if (($this->container['amount'] < 0)) {
            $invalidProperties[] = "invalid value for 'amount', must be bigger than or equal to 0.";
        }

        if ($this->container['handle'] === null) {
            $invalidProperties[] = "'handle' can't be null";
        }
        if ((mb_strlen($this->container['handle']) < 1)) {
            $invalidProperties[] = "invalid value for 'handle', the character length must be bigger than or equal to 1.";
        }

        if ($this->container['version'] === null) {
            $invalidProperties[] = "'version' can't be null";
        }
        if (($this->container['version'] < 1)) {
            $invalidProperties[] = "invalid value for 'version', must be bigger than or equal to 1.";
        }

        if ($this->container['state'] === null) {
            $invalidProperties[] = "'state' can't be null";
        }
        $allowedValues = $this->getStateAllowableValues();
        if (!is_null($this->container['state']) && !in_array($this->container['state'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'state', must be one of '%s'",
                $this->container['state'],
                implode("', '", $allowedValues)
            );
        }

        if ((mb_strlen($this->container['state']) < 1)) {
            $invalidProperties[] = "invalid value for 'state', the character length must be bigger than or equal to 1.";
        }

        if ($this->container['currency'] === null) {
            $invalidProperties[] = "'currency' can't be null";
        }
        if ((mb_strlen($this->container['currency']) < 1)) {
            $invalidProperties[] = "invalid value for 'currency', the character length must be bigger than or equal to 1.";
        }

        if ($this->container['created'] === null) {
            $invalidProperties[] = "'created' can't be null";
        }
        if ($this->container['scheduleType'] === null) {
            $invalidProperties[] = "'scheduleType' can't be null";
        }
        $allowedValues = $this->getScheduleTypeAllowableValues();
        if (!is_null($this->container['scheduleType']) && !in_array($this->container['scheduleType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'scheduleType', must be one of '%s'",
                $this->container['scheduleType'],
                implode("', '", $allowedValues)
            );
        }

        if ((mb_strlen($this->container['scheduleType']) < 1)) {
            $invalidProperties[] = "invalid value for 'scheduleType', the character length must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['quantity']) && ($this->container['quantity'] < 1)) {
            $invalidProperties[] = "invalid value for 'quantity', must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['renewalReminderEmailDays']) && ($this->container['renewalReminderEmailDays'] < 1)) {
            $invalidProperties[] = "invalid value for 'renewalReminderEmailDays', must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['trialReminderEmailDays']) && ($this->container['trialReminderEmailDays'] < 1)) {
            $invalidProperties[] = "invalid value for 'trialReminderEmailDays', must be bigger than or equal to 1.";
        }

        $allowedValues = $this->getPartialPeriodHandlingAllowableValues();
        if (!is_null($this->container['partialPeriodHandling']) && !in_array($this->container['partialPeriodHandling'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'partialPeriodHandling', must be one of '%s'",
                $this->container['partialPeriodHandling'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['setupFee']) && ($this->container['setupFee'] < 0)) {
            $invalidProperties[] = "invalid value for 'setupFee', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['minimumProratedAmount']) && ($this->container['minimumProratedAmount'] < 0)) {
            $invalidProperties[] = "invalid value for 'minimumProratedAmount', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['fixedCount']) && ($this->container['fixedCount'] < 1)) {
            $invalidProperties[] = "invalid value for 'fixedCount', must be bigger than or equal to 1.";
        }

        $allowedValues = $this->getFixedLifeTimeUnitAllowableValues();
        if (!is_null($this->container['fixedLifeTimeUnit']) && !in_array($this->container['fixedLifeTimeUnit'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'fixedLifeTimeUnit', must be one of '%s'",
                $this->container['fixedLifeTimeUnit'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['fixedLifeTimeLength']) && ($this->container['fixedLifeTimeLength'] > 12000)) {
            $invalidProperties[] = "invalid value for 'fixedLifeTimeLength', must be smaller than or equal to 12000.";
        }

        if (!is_null($this->container['fixedLifeTimeLength']) && ($this->container['fixedLifeTimeLength'] < 1)) {
            $invalidProperties[] = "invalid value for 'fixedLifeTimeLength', must be bigger than or equal to 1.";
        }

        $allowedValues = $this->getTrialIntervalUnitAllowableValues();
        if (!is_null($this->container['trialIntervalUnit']) && !in_array($this->container['trialIntervalUnit'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'trialIntervalUnit', must be one of '%s'",
                $this->container['trialIntervalUnit'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['trialIntervalLength']) && ($this->container['trialIntervalLength'] < 1)) {
            $invalidProperties[] = "invalid value for 'trialIntervalLength', must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['intervalLength']) && ($this->container['intervalLength'] > 12000)) {
            $invalidProperties[] = "invalid value for 'intervalLength', must be smaller than or equal to 12000.";
        }

        if (!is_null($this->container['intervalLength']) && ($this->container['intervalLength'] < 1)) {
            $invalidProperties[] = "invalid value for 'intervalLength', must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['scheduleFixedDay']) && ($this->container['scheduleFixedDay'] > 28)) {
            $invalidProperties[] = "invalid value for 'scheduleFixedDay', must be smaller than or equal to 28.";
        }

        if (!is_null($this->container['scheduleFixedDay']) && ($this->container['scheduleFixedDay'] < 1)) {
            $invalidProperties[] = "invalid value for 'scheduleFixedDay', must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['scheduleFixedHour']) && ($this->container['scheduleFixedHour'] > 23)) {
            $invalidProperties[] = "invalid value for 'scheduleFixedHour', must be smaller than or equal to 23.";
        }

        if (!is_null($this->container['scheduleFixedHour']) && ($this->container['scheduleFixedHour'] < 0)) {
            $invalidProperties[] = "invalid value for 'scheduleFixedHour', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['baseMonth']) && ($this->container['baseMonth'] > 12)) {
            $invalidProperties[] = "invalid value for 'baseMonth', must be smaller than or equal to 12.";
        }

        if (!is_null($this->container['baseMonth']) && ($this->container['baseMonth'] < 1)) {
            $invalidProperties[] = "invalid value for 'baseMonth', must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['noticePeriods']) && ($this->container['noticePeriods'] > 12000)) {
            $invalidProperties[] = "invalid value for 'noticePeriods', must be smaller than or equal to 12000.";
        }

        if (!is_null($this->container['noticePeriods']) && ($this->container['noticePeriods'] < 0)) {
            $invalidProperties[] = "invalid value for 'noticePeriods', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['fixationPeriods']) && ($this->container['fixationPeriods'] > 12000)) {
            $invalidProperties[] = "invalid value for 'fixationPeriods', must be smaller than or equal to 12000.";
        }

        if (!is_null($this->container['fixationPeriods']) && ($this->container['fixationPeriods'] < 0)) {
            $invalidProperties[] = "invalid value for 'fixationPeriods', must be bigger than or equal to 0.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name Name of the plan
     *
     * @return self
     */
    public function setName($name)
    {
        if (is_null($name)) {
            throw new \InvalidArgumentException('non-nullable name cannot be null');
        }

        if ((mb_strlen($name) < 1)) {
            throw new \InvalidArgumentException('invalid length for $name when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets amount
     *
     * @return int
     */
    public function getAmount()
    {
        return $this->container['amount'];
    }

    /**
     * Sets amount
     *
     * @param int $amount Amount for the plan in the smallest unit for the account currency
     *
     * @return self
     */
    public function setAmount($amount)
    {
        if (is_null($amount)) {
            throw new \InvalidArgumentException('non-nullable amount cannot be null');
        }

        if (($amount < 0)) {
            throw new \InvalidArgumentException('invalid value for $amount when calling Plan., must be bigger than or equal to 0.');
        }

        $this->container['amount'] = $amount;

        return $this;
    }

    /**
     * Gets handle
     *
     * @return string
     */
    public function getHandle()
    {
        return $this->container['handle'];
    }

    /**
     * Sets handle
     *
     * @param string $handle Per account unique handle for the subscription plan. Max length 255 with allowable characters [a-zA-Z0-9_.-@].
     *
     * @return self
     */
    public function setHandle($handle)
    {
        if (is_null($handle)) {
            throw new \InvalidArgumentException('non-nullable handle cannot be null');
        }

        if ((mb_strlen($handle) < 1)) {
            throw new \InvalidArgumentException('invalid length for $handle when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['handle'] = $handle;

        return $this;
    }

    /**
     * Gets version
     *
     * @return int
     */
    public function getVersion()
    {
        return $this->container['version'];
    }

    /**
     * Sets version
     *
     * @param int $version Plan version
     *
     * @return self
     */
    public function setVersion($version)
    {
        if (is_null($version)) {
            throw new \InvalidArgumentException('non-nullable version cannot be null');
        }

        if (($version < 1)) {
            throw new \InvalidArgumentException('invalid value for $version when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['version'] = $version;

        return $this;
    }

    /**
     * Gets state
     *
     * @return string
     */
    public function getState()
    {
        return $this->container['state'];
    }

    /**
     * Sets state
     *
     * @param string $state State of the subscription plan one of the following: `active`, `superseded`, `deleted`
     *
     * @return self
     */
    public function setState($state)
    {
        if (is_null($state)) {
            throw new \InvalidArgumentException('non-nullable state cannot be null');
        }
        $allowedValues = $this->getStateAllowableValues();
        if (!in_array($state, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'state', must be one of '%s'",
                    $state,
                    implode("', '", $allowedValues)
                )
            );
        }

        if ((mb_strlen($state) < 1)) {
            throw new \InvalidArgumentException('invalid length for $state when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['state'] = $state;

        return $this;
    }

    /**
     * Gets currency
     *
     * @return string
     */
    public function getCurrency()
    {
        return $this->container['currency'];
    }

    /**
     * Sets currency
     *
     * @param string $currency Currency for the subscription plan in [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) three letter alpha code
     *
     * @return self
     */
    public function setCurrency($currency)
    {
        if (is_null($currency)) {
            throw new \InvalidArgumentException('non-nullable currency cannot be null');
        }

        if ((mb_strlen($currency) < 1)) {
            throw new \InvalidArgumentException('invalid length for $currency when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['currency'] = $currency;

        return $this;
    }

    /**
     * Gets created
     *
     * @return \DateTime
     */
    public function getCreated()
    {
        return $this->container['created'];
    }

    /**
     * Sets created
     *
     * @param \DateTime $created Date when the subscription plan was created. In ISO-8601 extended offset date-time format.
     *
     * @return self
     */
    public function setCreated($created)
    {
        if (is_null($created)) {
            throw new \InvalidArgumentException('non-nullable created cannot be null');
        }
        $this->container['created'] = $created;

        return $this;
    }

    /**
     * Gets scheduleType
     *
     * @return string
     */
    public function getScheduleType()
    {
        return $this->container['scheduleType'];
    }

    /**
     * Sets scheduleType
     *
     * @param string $scheduleType Scheduling type, one of the following: `manual`, `daily`, `weekly_fixedday`, `month_startdate`, `month_fixedday`, `month_lastday`. See documentation for descriptions of the different types.
     *
     * @return self
     */
    public function setScheduleType($scheduleType)
    {
        if (is_null($scheduleType)) {
            throw new \InvalidArgumentException('non-nullable scheduleType cannot be null');
        }
        $allowedValues = $this->getScheduleTypeAllowableValues();
        if (!in_array($scheduleType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'scheduleType', must be one of '%s'",
                    $scheduleType,
                    implode("', '", $allowedValues)
                )
            );
        }

        if ((mb_strlen($scheduleType) < 1)) {
            throw new \InvalidArgumentException('invalid length for $scheduleType when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['scheduleType'] = $scheduleType;

        return $this;
    }

    /**
     * Gets description
     *
     * @return string|null
     */
    public function getDescription()
    {
        return $this->container['description'];
    }

    /**
     * Sets description
     *
     * @param string|null $description Description of the plan
     *
     * @return self
     */
    public function setDescription($description)
    {
        if (is_null($description)) {
            throw new \InvalidArgumentException('non-nullable description cannot be null');
        }
        $this->container['description'] = $description;

        return $this;
    }

    /**
     * Gets vat
     *
     * @return float|null
     */
    public function getVat()
    {
        return $this->container['vat'];
    }

    /**
     * Sets vat
     *
     * @param float|null $vat Optional vat for this plan. Account default is used if none given.
     *
     * @return self
     */
    public function setVat($vat)
    {
        if (is_null($vat)) {
            throw new \InvalidArgumentException('non-nullable vat cannot be null');
        }
        $this->container['vat'] = $vat;

        return $this;
    }

    /**
     * Gets quantity
     *
     * @return int|null
     */
    public function getQuantity()
    {
        return $this->container['quantity'];
    }

    /**
     * Sets quantity
     *
     * @param int|null $quantity Optional default quantity of the subscription plan product for new subscriptions. Default is 1.
     *
     * @return self
     */
    public function setQuantity($quantity)
    {
        if (is_null($quantity)) {
            throw new \InvalidArgumentException('non-nullable quantity cannot be null');
        }

        if (($quantity < 1)) {
            throw new \InvalidArgumentException('invalid value for $quantity when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['quantity'] = $quantity;

        return $this;
    }

    /**
     * Gets prepaid
     *
     * @return bool|null
     */
    public function getPrepaid()
    {
        return $this->container['prepaid'];
    }

    /**
     * Sets prepaid
     *
     * @param bool|null $prepaid Subscriptions can either be prepaid where an amount is paid in advance, or the opposite. This setting only relates to handling of pause scenarios.
     *
     * @return self
     */
    public function setPrepaid($prepaid)
    {
        if (is_null($prepaid)) {
            throw new \InvalidArgumentException('non-nullable prepaid cannot be null');
        }
        $this->container['prepaid'] = $prepaid;

        return $this;
    }

    /**
     * Gets deleted
     *
     * @return \DateTime|null
     */
    public function getDeleted()
    {
        return $this->container['deleted'];
    }

    /**
     * Sets deleted
     *
     * @param \DateTime|null $deleted Date when the subscription plan was deleted. In ISO-8601 extended offset date-time format.
     *
     * @return self
     */
    public function setDeleted($deleted)
    {
        if (is_null($deleted)) {
            throw new \InvalidArgumentException('non-nullable deleted cannot be null');
        }
        $this->container['deleted'] = $deleted;

        return $this;
    }

    /**
     * Gets dunningPlan
     *
     * @return string|null
     */
    public function getDunningPlan()
    {
        return $this->container['dunningPlan'];
    }

    /**
     * Sets dunningPlan
     *
     * @param string|null $dunningPlan Dunning plan by handle to use for the subscription plan. Default dunning plan will be used if none given.
     *
     * @return self
     */
    public function setDunningPlan($dunningPlan)
    {
        if (is_null($dunningPlan)) {
            throw new \InvalidArgumentException('non-nullable dunningPlan cannot be null');
        }
        $this->container['dunningPlan'] = $dunningPlan;

        return $this;
    }

    /**
     * Gets taxPolicy
     *
     * @return string|null
     */
    public function getTaxPolicy()
    {
        return $this->container['taxPolicy'];
    }

    /**
     * Sets taxPolicy
     *
     * @param string|null $taxPolicy Optional tax policy handle for this plan. If vat and tax policy is given, vat will be ignored.
     *
     * @return self
     */
    public function setTaxPolicy($taxPolicy)
    {
        if (is_null($taxPolicy)) {
            throw new \InvalidArgumentException('non-nullable taxPolicy cannot be null');
        }
        $this->container['taxPolicy'] = $taxPolicy;

        return $this;
    }

    /**
     * Gets renewalReminderEmailDays
     *
     * @return int|null
     */
    public function getRenewalReminderEmailDays()
    {
        return $this->container['renewalReminderEmailDays'];
    }

    /**
     * Sets renewalReminderEmailDays
     *
     * @param int|null $renewalReminderEmailDays Optional renewal reminder email settings. Number of days before next billing to send a reminder email.
     *
     * @return self
     */
    public function setRenewalReminderEmailDays($renewalReminderEmailDays)
    {
        if (is_null($renewalReminderEmailDays)) {
            throw new \InvalidArgumentException('non-nullable renewalReminderEmailDays cannot be null');
        }

        if (($renewalReminderEmailDays < 1)) {
            throw new \InvalidArgumentException('invalid value for $renewalReminderEmailDays when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['renewalReminderEmailDays'] = $renewalReminderEmailDays;

        return $this;
    }

    /**
     * Gets trialReminderEmailDays
     *
     * @return int|null
     */
    public function getTrialReminderEmailDays()
    {
        return $this->container['trialReminderEmailDays'];
    }

    /**
     * Sets trialReminderEmailDays
     *
     * @param int|null $trialReminderEmailDays Optional end of trial reminder email settings. Number of days before end of trial to send a reminder email.
     *
     * @return self
     */
    public function setTrialReminderEmailDays($trialReminderEmailDays)
    {
        if (is_null($trialReminderEmailDays)) {
            throw new \InvalidArgumentException('non-nullable trialReminderEmailDays cannot be null');
        }

        if (($trialReminderEmailDays < 1)) {
            throw new \InvalidArgumentException('invalid value for $trialReminderEmailDays when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['trialReminderEmailDays'] = $trialReminderEmailDays;

        return $this;
    }

    /**
     * Gets partialPeriodHandling
     *
     * @return string|null
     */
    public function getPartialPeriodHandling()
    {
        return $this->container['partialPeriodHandling'];
    }

    /**
     * Sets partialPeriodHandling
     *
     * @param string|null $partialPeriodHandling How to handle a potential initial partial billing period for fixed day scheduling. The options are to bill for a full period, bill prorated for the partial period, bill a zero amoumt, or not to consider the period before first fixed day a billing period. The default is to bill prorated. Options: `bill_full`, `bill_prorated`, `bill_zero_amount`, `no_bill`.
     *
     * @return self
     */
    public function setPartialPeriodHandling($partialPeriodHandling)
    {
        if (is_null($partialPeriodHandling)) {
            throw new \InvalidArgumentException('non-nullable partialPeriodHandling cannot be null');
        }
        $allowedValues = $this->getPartialPeriodHandlingAllowableValues();
        if (!in_array($partialPeriodHandling, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'partialPeriodHandling', must be one of '%s'",
                    $partialPeriodHandling,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['partialPeriodHandling'] = $partialPeriodHandling;

        return $this;
    }

    /**
     * Gets includeZeroAmount
     *
     * @return bool|null
     */
    public function getIncludeZeroAmount()
    {
        return $this->container['includeZeroAmount'];
    }

    /**
     * Sets includeZeroAmount
     *
     * @param bool|null $includeZeroAmount Whether to add a zero amount order line to subscription invoices if plan amount is zero or the subscription overrides to zero amount. The default is to not include the line. If no other order lines are present the plan order line will be added.
     *
     * @return self
     */
    public function setIncludeZeroAmount($includeZeroAmount)
    {
        if (is_null($includeZeroAmount)) {
            throw new \InvalidArgumentException('non-nullable includeZeroAmount cannot be null');
        }
        $this->container['includeZeroAmount'] = $includeZeroAmount;

        return $this;
    }

    /**
     * Gets setupFee
     *
     * @return int|null
     */
    public function getSetupFee()
    {
        return $this->container['setupFee'];
    }

    /**
     * Sets setupFee
     *
     * @param int|null $setupFee Optional one-time setup fee billed with the first invoice or as a separate invoice depending on the setting `setup_fee_handling`.
     *
     * @return self
     */
    public function setSetupFee($setupFee)
    {
        if (is_null($setupFee)) {
            throw new \InvalidArgumentException('non-nullable setupFee cannot be null');
        }

        if (($setupFee < 0)) {
            throw new \InvalidArgumentException('invalid value for $setupFee when calling Plan., must be bigger than or equal to 0.');
        }

        $this->container['setupFee'] = $setupFee;

        return $this;
    }

    /**
     * Gets setupFeeText
     *
     * @return string|null
     */
    public function getSetupFeeText()
    {
        return $this->container['setupFeeText'];
    }

    /**
     * Sets setupFeeText
     *
     * @param string|null $setupFeeText Optional invoice order text for the setup fee that
     *
     * @return self
     */
    public function setSetupFeeText($setupFeeText)
    {
        if (is_null($setupFeeText)) {
            throw new \InvalidArgumentException('non-nullable setupFeeText cannot be null');
        }
        $this->container['setupFeeText'] = $setupFeeText;

        return $this;
    }

    /**
     * Gets setupFeeHandling
     *
     * @return string|null
     */
    public function getSetupFeeHandling()
    {
        return $this->container['setupFeeHandling'];
    }

    /**
     * Sets setupFeeHandling
     *
     * @param string|null $setupFeeHandling How the billing of the setup fee should be done. The options are: `first` - include setup fee as order line on the first scheduled invoice. `separate` - create a separate invoice for the setup fee, is appropriate if first invoice is not in conjunction with creation. `separate_conditional` - create a separate invoice for setup fee if the first invoice is not created in conjunction with the creation. Default is `first`.
     *
     * @return self
     */
    public function setSetupFeeHandling($setupFeeHandling)
    {
        if (is_null($setupFeeHandling)) {
            throw new \InvalidArgumentException('non-nullable setupFeeHandling cannot be null');
        }
        $this->container['setupFeeHandling'] = $setupFeeHandling;

        return $this;
    }

    /**
     * Gets partialProrationDays
     *
     * @return bool|null
     */
    public function getPartialProrationDays()
    {
        return $this->container['partialProrationDays'];
    }

    /**
     * Sets partialProrationDays
     *
     * @param bool|null $partialProrationDays For fixed day scheduling and prorated partial handling calculate prorated amount using whole days counting start day as a full day, or use by the minute proration calculation from start date time to the next period start. Default is true (whole days).
     *
     * @return self
     */
    public function setPartialProrationDays($partialProrationDays)
    {
        if (is_null($partialProrationDays)) {
            throw new \InvalidArgumentException('non-nullable partialProrationDays cannot be null');
        }
        $this->container['partialProrationDays'] = $partialProrationDays;

        return $this;
    }

    /**
     * Gets fixedTrialDays
     *
     * @return bool|null
     */
    public function getFixedTrialDays()
    {
        return $this->container['fixedTrialDays'];
    }

    /**
     * Sets fixedTrialDays
     *
     * @param bool|null $fixedTrialDays When using trial for fixed day scheduling use this setting to control if trial expires at midnight or the trial period is down to the minute. Default is true (trial until start of day). Trial in days can only be true if `partial_proration_days` is also set to true.
     *
     * @return self
     */
    public function setFixedTrialDays($fixedTrialDays)
    {
        if (is_null($fixedTrialDays)) {
            throw new \InvalidArgumentException('non-nullable fixedTrialDays cannot be null');
        }
        $this->container['fixedTrialDays'] = $fixedTrialDays;

        return $this;
    }

    /**
     * Gets minimumProratedAmount
     *
     * @return int|null
     */
    public function getMinimumProratedAmount()
    {
        return $this->container['minimumProratedAmount'];
    }

    /**
     * Sets minimumProratedAmount
     *
     * @param int|null $minimumProratedAmount When using prorated partial handling the prorated amount for plan and add-ons might result in very small amounts. A minimum prorated amount for plan and add-ons can be defined. If the prorated amount is below this minimum the amount will be changed to zero.
     *
     * @return self
     */
    public function setMinimumProratedAmount($minimumProratedAmount)
    {
        if (is_null($minimumProratedAmount)) {
            throw new \InvalidArgumentException('non-nullable minimumProratedAmount cannot be null');
        }

        if (($minimumProratedAmount < 0)) {
            throw new \InvalidArgumentException('invalid value for $minimumProratedAmount when calling Plan., must be bigger than or equal to 0.');
        }

        $this->container['minimumProratedAmount'] = $minimumProratedAmount;

        return $this;
    }

    /**
     * Gets accountFunding
     *
     * @return bool|null
     */
    public function getAccountFunding()
    {
        return $this->container['accountFunding'];
    }

    /**
     * Sets accountFunding
     *
     * @param bool|null $accountFunding Indicates that Account Funding Transaction (AFT) is requested.
     *
     * @return self
     */
    public function setAccountFunding($accountFunding)
    {
        if (is_null($accountFunding)) {
            throw new \InvalidArgumentException('non-nullable accountFunding cannot be null');
        }
        $this->container['accountFunding'] = $accountFunding;

        return $this;
    }

    /**
     * Gets amountInclVat
     *
     * @return bool|null
     */
    public function getAmountInclVat()
    {
        return $this->container['amountInclVat'];
    }

    /**
     * Sets amountInclVat
     *
     * @param bool|null $amountInclVat Whether the amount is including VAT. Default true.
     *
     * @return self
     */
    public function setAmountInclVat($amountInclVat)
    {
        if (is_null($amountInclVat)) {
            throw new \InvalidArgumentException('non-nullable amountInclVat cannot be null');
        }
        $this->container['amountInclVat'] = $amountInclVat;

        return $this;
    }

    /**
     * Gets fixedCount
     *
     * @return int|null
     */
    public function getFixedCount()
    {
        return $this->container['fixedCount'];
    }

    /**
     * Sets fixedCount
     *
     * @param int|null $fixedCount Fixed number of renewals for subscriptions using this plan. Equals the number of scheduled invoices. Default is no fixed amount of renewals.
     *
     * @return self
     */
    public function setFixedCount($fixedCount)
    {
        if (is_null($fixedCount)) {
            throw new \InvalidArgumentException('non-nullable fixedCount cannot be null');
        }

        if (($fixedCount < 1)) {
            throw new \InvalidArgumentException('invalid value for $fixedCount when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['fixedCount'] = $fixedCount;

        return $this;
    }

    /**
     * Gets fixedLifeTimeUnit
     *
     * @return string|null
     */
    public function getFixedLifeTimeUnit()
    {
        return $this->container['fixedLifeTimeUnit'];
    }

    /**
     * Sets fixedLifeTimeUnit
     *
     * @param string|null $fixedLifeTimeUnit Time unit use for fixed life time
     *
     * @return self
     */
    public function setFixedLifeTimeUnit($fixedLifeTimeUnit)
    {
        if (is_null($fixedLifeTimeUnit)) {
            throw new \InvalidArgumentException('non-nullable fixedLifeTimeUnit cannot be null');
        }
        $allowedValues = $this->getFixedLifeTimeUnitAllowableValues();
        if (!in_array($fixedLifeTimeUnit, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'fixedLifeTimeUnit', must be one of '%s'",
                    $fixedLifeTimeUnit,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['fixedLifeTimeUnit'] = $fixedLifeTimeUnit;

        return $this;
    }

    /**
     * Gets fixedLifeTimeLength
     *
     * @return int|null
     */
    public function getFixedLifeTimeLength()
    {
        return $this->container['fixedLifeTimeLength'];
    }

    /**
     * Sets fixedLifeTimeLength
     *
     * @param int|null $fixedLifeTimeLength Optional fixed life time length for subscriptions using this plan. E.g. 12 months. Subscriptions will cancel after the fixed life time and expire when the active billing cycle ends.
     *
     * @return self
     */
    public function setFixedLifeTimeLength($fixedLifeTimeLength)
    {
        if (is_null($fixedLifeTimeLength)) {
            throw new \InvalidArgumentException('non-nullable fixedLifeTimeLength cannot be null');
        }

        if (($fixedLifeTimeLength > 12000)) {
            throw new \InvalidArgumentException('invalid value for $fixedLifeTimeLength when calling Plan., must be smaller than or equal to 12000.');
        }
        if (($fixedLifeTimeLength < 1)) {
            throw new \InvalidArgumentException('invalid value for $fixedLifeTimeLength when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['fixedLifeTimeLength'] = $fixedLifeTimeLength;

        return $this;
    }

    /**
     * Gets trialIntervalUnit
     *
     * @return string|null
     */
    public function getTrialIntervalUnit()
    {
        return $this->container['trialIntervalUnit'];
    }

    /**
     * Sets trialIntervalUnit
     *
     * @param string|null $trialIntervalUnit Time unit for free trial period
     *
     * @return self
     */
    public function setTrialIntervalUnit($trialIntervalUnit)
    {
        if (is_null($trialIntervalUnit)) {
            throw new \InvalidArgumentException('non-nullable trialIntervalUnit cannot be null');
        }
        $allowedValues = $this->getTrialIntervalUnitAllowableValues();
        if (!in_array($trialIntervalUnit, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'trialIntervalUnit', must be one of '%s'",
                    $trialIntervalUnit,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['trialIntervalUnit'] = $trialIntervalUnit;

        return $this;
    }

    /**
     * Gets trialIntervalLength
     *
     * @return int|null
     */
    public function getTrialIntervalLength()
    {
        return $this->container['trialIntervalLength'];
    }

    /**
     * Sets trialIntervalLength
     *
     * @param int|null $trialIntervalLength Optional free trial interval length. E.g. 1 monts.
     *
     * @return self
     */
    public function setTrialIntervalLength($trialIntervalLength)
    {
        if (is_null($trialIntervalLength)) {
            throw new \InvalidArgumentException('non-nullable trialIntervalLength cannot be null');
        }

        if (($trialIntervalLength < 1)) {
            throw new \InvalidArgumentException('invalid value for $trialIntervalLength when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['trialIntervalLength'] = $trialIntervalLength;

        return $this;
    }

    /**
     * Gets intervalLength
     *
     * @return int|null
     */
    public function getIntervalLength()
    {
        return $this->container['intervalLength'];
    }

    /**
     * Sets intervalLength
     *
     * @param int|null $intervalLength The length of intervals. E.g. every second month or every 14 days.
     *
     * @return self
     */
    public function setIntervalLength($intervalLength)
    {
        if (is_null($intervalLength)) {
            throw new \InvalidArgumentException('non-nullable intervalLength cannot be null');
        }

        if (($intervalLength > 12000)) {
            throw new \InvalidArgumentException('invalid value for $intervalLength when calling Plan., must be smaller than or equal to 12000.');
        }
        if (($intervalLength < 1)) {
            throw new \InvalidArgumentException('invalid value for $intervalLength when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['intervalLength'] = $intervalLength;

        return $this;
    }

    /**
     * Gets scheduleFixedDay
     *
     * @return int|null
     */
    public function getScheduleFixedDay()
    {
        return $this->container['scheduleFixedDay'];
    }

    /**
     * Sets scheduleFixedDay
     *
     * @param int|null $scheduleFixedDay If a fixed day scheduling type is used a fixed day must be provided. For months the allowed value is 1-28 for weeks it is 1-7
     *
     * @return self
     */
    public function setScheduleFixedDay($scheduleFixedDay)
    {
        if (is_null($scheduleFixedDay)) {
            throw new \InvalidArgumentException('non-nullable scheduleFixedDay cannot be null');
        }

        if (($scheduleFixedDay > 28)) {
            throw new \InvalidArgumentException('invalid value for $scheduleFixedDay when calling Plan., must be smaller than or equal to 28.');
        }
        if (($scheduleFixedDay < 1)) {
            throw new \InvalidArgumentException('invalid value for $scheduleFixedDay when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['scheduleFixedDay'] = $scheduleFixedDay;

        return $this;
    }

    /**
     * Gets scheduleFixedHour
     *
     * @return int|null
     */
    public function getScheduleFixedHour()
    {
        return $this->container['scheduleFixedHour'];
    }

    /**
     * Sets scheduleFixedHour
     *
     * @param int|null $scheduleFixedHour Fixed hour (0-23) for monthly and weekly fixed day schedules. If not null, subscription will be scheduled at this hour.
     *
     * @return self
     */
    public function setScheduleFixedHour($scheduleFixedHour)
    {
        if (is_null($scheduleFixedHour)) {
            throw new \InvalidArgumentException('non-nullable scheduleFixedHour cannot be null');
        }

        if (($scheduleFixedHour > 23)) {
            throw new \InvalidArgumentException('invalid value for $scheduleFixedHour when calling Plan., must be smaller than or equal to 23.');
        }
        if (($scheduleFixedHour < 0)) {
            throw new \InvalidArgumentException('invalid value for $scheduleFixedHour when calling Plan., must be bigger than or equal to 0.');
        }

        $this->container['scheduleFixedHour'] = $scheduleFixedHour;

        return $this;
    }

    /**
     * Gets baseMonth
     *
     * @return int|null
     */
    public function getBaseMonth()
    {
        return $this->container['baseMonth'];
    }

    /**
     * Sets baseMonth
     *
     * @param int|null $baseMonth For fixed month schedule types the base month can be used to control which months are eligible for start of first billing period. The eligible months are calculated as `base_month + k * interval_length` up to 12. E.g. to use quaterly billing in the months jan-apr-jul-oct, `base_month` 1 and `interval_length` 3 can be used. If not defined the first fixed day will be used as start of first billing period.
     *
     * @return self
     */
    public function setBaseMonth($baseMonth)
    {
        if (is_null($baseMonth)) {
            throw new \InvalidArgumentException('non-nullable baseMonth cannot be null');
        }

        if (($baseMonth > 12)) {
            throw new \InvalidArgumentException('invalid value for $baseMonth when calling Plan., must be smaller than or equal to 12.');
        }
        if (($baseMonth < 1)) {
            throw new \InvalidArgumentException('invalid value for $baseMonth when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['baseMonth'] = $baseMonth;

        return $this;
    }

    /**
     * Gets noticePeriods
     *
     * @return int|null
     */
    public function getNoticePeriods()
    {
        return $this->container['noticePeriods'];
    }

    /**
     * Sets noticePeriods
     *
     * @param int|null $noticePeriods Optional number of notice periods for a cancel. The subscription will be cancelled for this number of full periods before expiring. Either from the cancellation date, or from the end of the the current period. See `notice_periods_after_current`. The default is to expire at the end of current period (0). A value of 1 (and `notice_periods_after_current` set to true) will for example result in a scenario where the subscription is cancelled until the end of current period, and then for the full subsequent period before expiring.
     *
     * @return self
     */
    public function setNoticePeriods($noticePeriods)
    {
        if (is_null($noticePeriods)) {
            throw new \InvalidArgumentException('non-nullable noticePeriods cannot be null');
        }

        if (($noticePeriods > 12000)) {
            throw new \InvalidArgumentException('invalid value for $noticePeriods when calling Plan., must be smaller than or equal to 12000.');
        }
        if (($noticePeriods < 0)) {
            throw new \InvalidArgumentException('invalid value for $noticePeriods when calling Plan., must be bigger than or equal to 0.');
        }

        $this->container['noticePeriods'] = $noticePeriods;

        return $this;
    }

    /**
     * Gets noticePeriodsAfterCurrent
     *
     * @return bool|null
     */
    public function getNoticePeriodsAfterCurrent()
    {
        return $this->container['noticePeriodsAfterCurrent'];
    }

    /**
     * Sets noticePeriodsAfterCurrent
     *
     * @param bool|null $noticePeriodsAfterCurrent If notice periods is set, this option controls whether the number of full notice periods should start at the end of the current period, or run from cancellation date and result in a partial period with partial amount for the last period. The default is true. E.g. if set to false and `notice_periods = 1` then the subscription will be cancelled for exactly for one period from the cancellation time and a partial amount will be billed at the start of the next billing period.
     *
     * @return self
     */
    public function setNoticePeriodsAfterCurrent($noticePeriodsAfterCurrent)
    {
        if (is_null($noticePeriodsAfterCurrent)) {
            throw new \InvalidArgumentException('non-nullable noticePeriodsAfterCurrent cannot be null');
        }
        $this->container['noticePeriodsAfterCurrent'] = $noticePeriodsAfterCurrent;

        return $this;
    }

    /**
     * Gets fixationPeriods
     *
     * @return int|null
     */
    public function getFixationPeriods()
    {
        return $this->container['fixationPeriods'];
    }

    /**
     * Sets fixationPeriods
     *
     * @param int|null $fixationPeriods Optional number of fixation periods. Fixation periods will guarantee that a subscription will have this number of paid full periods before expiring after a cancel. Default is to have no requirement (0).
     *
     * @return self
     */
    public function setFixationPeriods($fixationPeriods)
    {
        if (is_null($fixationPeriods)) {
            throw new \InvalidArgumentException('non-nullable fixationPeriods cannot be null');
        }

        if (($fixationPeriods > 12000)) {
            throw new \InvalidArgumentException('invalid value for $fixationPeriods when calling Plan., must be smaller than or equal to 12000.');
        }
        if (($fixationPeriods < 0)) {
            throw new \InvalidArgumentException('invalid value for $fixationPeriods when calling Plan., must be bigger than or equal to 0.');
        }

        $this->container['fixationPeriods'] = $fixationPeriods;

        return $this;
    }

    /**
     * Gets fixationPeriodsFull
     *
     * @return bool|null
     */
    public function getFixationPeriodsFull()
    {
        return $this->container['fixationPeriodsFull'];
    }

    /**
     * Sets fixationPeriodsFull
     *
     * @param bool|null $fixationPeriodsFull If fixation periods are defined, and the subscription can have a partial prorated first period, this parameter controls if the the last period should be full, or partial to give exactly `fixation_periods` paid periods. Default is false.
     *
     * @return self
     */
    public function setFixationPeriodsFull($fixationPeriodsFull)
    {
        if (is_null($fixationPeriodsFull)) {
            throw new \InvalidArgumentException('non-nullable fixationPeriodsFull cannot be null');
        }
        $this->container['fixationPeriodsFull'] = $fixationPeriodsFull;

        return $this;
    }

    /**
     * Gets entitlements
     *
     * @return string[]|null
     */
    public function getEntitlements()
    {
        return $this->container['entitlements'];
    }

    /**
     * Sets entitlements
     *
     * @param string[]|null $entitlements List of entitlement handles to be added to the plan
     *
     * @return self
     */
    public function setEntitlements($entitlements)
    {
        if (is_null($entitlements)) {
            throw new \InvalidArgumentException('non-nullable entitlements cannot be null');
        }


        $this->container['entitlements'] = $entitlements;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


